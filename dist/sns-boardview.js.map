{"version":3,"file":"sns-boardview.js","sources":["../src/sns-boardview.ts"],"sourcesContent":["/*******************************************************************************\n*                                                                              *\n*                BoardView for \"Shareable Note Stickers\" (SNS)                 *\n*                                                                              *\n*******************************************************************************/\n\n  import {\n    allowBoolean,\n    allowInteger, allowOrdinal, allowCardinal,\n    allowText, allowTextline,\n    allowFunction,\n    allowListSatisfying,\n    allowOneOf,\n  } from 'javascript-interface-library'\n\n  import {\n    SNS_Board, SNS_Sticker, SNS_Dialog,\n    ValueIsSticker,\n    allowBoard,\n    CSSStyleOfVisual,\n  } from 'shareable-note-stickers'\n\n  import Conversion from 'svelte-coordinate-conversion'\n  const { fromDocumentTo } = Conversion\n\n  import { html, Component } from 'htm/preact'\n\n// @ts-ignore TS7016 *C* sometimes, I hate package management\n  import { DragRecognizerFor, DragClickRecognizerFor } from 'protoux'\n\n/**** install stylesheet for this BoardView ****/\n\n  const Stylesheet = document.createElement('style')\n    Stylesheet.setAttribute('id','SNS Stylesheet')\n    Stylesheet.innerHTML = `/*******************************************************************************\n*                                                                              *\n*                        Shareable Note Stickers (SNS)                         *\n*                                                                              *\n*******************************************************************************/\n\n/**** all SNS elements are absolutely positioned ****/\n\n  .SNS {\n    display:block; position:absolute;\n    margin:0px; padding:0px;\n    background:none; border:none; border-radius:0px; outline:none;\n  }\n\n/**** elements of class \"SNS Content\" cover their whole container ****/\n\n  .SNS.Content {\n    display:block; position:absolute;\n    left:0px; top:0px; width:100%; height:100%;\n  }\n\n/**** \"brokenSticker\" and Error Indicator ****/\n\n  .SNS.brokenSticker {\n    overflow:hidden;\n    border:dotted 1px orange; background:rgba(255,0,0,0.1);\n  }\n\n  .SNS.ErrorIndicator {\n    overflow:hidden;\n    left:0px; top:0px; width:24px; height:24px;\n    background:url(\"data:image/svg+xml,%3C%3Fxml version='1.0' encoding='utf-8'%3F%3E%3Csvg width='24px' height='24px' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M12 17.0001H12.01M12 10.0001V14.0001M6.41209 21.0001H17.588C19.3696 21.0001 20.2604 21.0001 20.783 20.6254C21.2389 20.2985 21.5365 19.7951 21.6033 19.238C21.6798 18.5996 21.2505 17.819 20.3918 16.2579L14.8039 6.09805C13.8897 4.4359 13.4326 3.60482 12.8286 3.32987C12.3022 3.09024 11.6978 3.09024 11.1714 3.32987C10.5674 3.60482 10.1103 4.4359 9.19614 6.09805L3.6082 16.2579C2.74959 17.819 2.32028 18.5996 2.39677 19.238C2.46351 19.7951 2.76116 20.2985 3.21709 20.6254C3.7396 21.0001 4.63043 21.0001 6.41209 21.0001Z' stroke='orange' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' fill='white'/%3E%3C/svg%3E\");\n    pointer-events:auto;\n  }\n\n\n/**** BoardView ****/\n\n  .SNS.BoardView {\n    left:0px; top:0px; right:0px; bottom:0px;\n  }\n\n/**** Sticker and Contents, Cover ****/\n\n  .SNS.Sticker {}\n  .SNS.Sticker > .SNS {\n    -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none;\n    user-select:none;\n\n    display:block; position:absolute;\n    left:0px; top:0px; width:100%; height:100%; right:auto; bottom:auto;\n  }\n\n  .SNS.Cover {\n    -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none;\n    user-select:none;\n\n    z-index:1000000;\n  }\n\n/**** Selection Markers ****/\n\n  .SNS.Sticker.selected, .SNS.Cover[selected] {\n    outline:dotted 2px orangered;\n  }\n\n  .SNS.ShapeHandle {\n    width:8px; height:8px;\n    background:orangered; border:solid 1px darkgray;\n    z-index:1000001; /* above .SNS.Cover */\n  }\n\n/**** Selection Lasso ****/\n\n  .SNS.Lasso {\n    background:rgba(255,69,0, 0.1); /* border:dashed 2px orangered; */\n  }\n\n/**** Dragging Guides ****/\n\n  .SNS.horizontalGuide.Edge {\n    left:0px; right:0px; height:1px;\n    border-top:dashed 1px orangered;\n  }\n  .SNS.verticalGuide.Edge {\n    top:0px; bottom:0px; width:1px;\n    border-left:dashed 1px orangered;\n  }\n\n  .SNS.horizontalGuide.Center {\n    left:0px; right:0px; height:1px;\n    border-top:dotted 1px orangered;\n  }\n  .SNS.verticalGuide.Center {\n    top:0px; bottom:0px; width:1px;\n    border-left:dotted 1px orangered;\n  }\n\n/**** Placeholder ****/\n\n  .SNS.Placeholder {\n    display:block; position:relative;\n    width:100%; height:100%;\n  }\n\n  .SNS.Placeholder > * {\n    display:block; position:absolute;\n    left:50%; top:50%;\n    transform:translate(-55%,-50%);\n    white-space:nowrap;\n  }\n\n/**** custom Dialogs ****/\n\n  .PUX.Dialog > .ContentPane {\n    position:absolute; left:0px; top:30px; right:0px; bottom:0px;\n  }\n  .PUX.ResizableDialog > .ContentPane {\n    position:absolute; left:0px; top:30px; right:0px; bottom:10px;\n  }\n`\n  document.head.appendChild(Stylesheet)\n\n/**** make some existing types indexable ****/\n\n  interface Indexable { [Key:string]:any }\n\n//------------------------------------------------------------------------------\n//--                             Type Definitions                             --\n//------------------------------------------------------------------------------\n\n/**** geometry-related types ****/\n\n  export type SNS_Location  = number         // mainly for illustrative purposes\n  export type SNS_Dimension = number                                     // dto.\n  export type SNS_Position  = { x:SNS_Location,y:SNS_Location }\n  export type SNS_Size      = { Width:SNS_Dimension,Height:SNS_Dimension }\n  export type SNS_Geometry  = { x:SNS_Location,y:SNS_Location, Width:SNS_Dimension,Height:SNS_Dimension }\n\n//------------------------------------------------------------------------------\n//--                              SNS_BoardView                               --\n//------------------------------------------------------------------------------\n\n  export class SNS_BoardView extends Component {\n    private _Board:SNS_Board|undefined\n    private _Mode:'touch'|'enclose' = 'enclose'\n\n    private _StickerList:SNS_Sticker[] = []\n    private _pointedSticker:SNS_Sticker|undefined\n    private _selectedStickers:SNS_Sticker[] = []       // for dragging & shaping\n    private _SelectionLimit:number = Infinity\n\n    private _LassoStart:SNS_Position|undefined\n    private _LassoEnd:SNS_Position|undefined\n    private _SelectionBeforeLasso:SNS_Sticker[] = []\n\n    private _ShapeMode:string|undefined\n    private _shapedStickers:SNS_Sticker[]|undefined\n    private _initialGeometries:SNS_Geometry[]|undefined\n\n    private _SnapToGrid:boolean = false\n    private _GridWidth:number   = 1\n    private _GridHeight:number  = 1\n\n    private _StickerRecognizerSlot = {}\n    private _ShapeHandleRecognizerSlot = {}\n    private _LassoRecognizerSlot = {}\n\n    public state:Indexable = { Value:0 }\n\n  /**** _mountBoard ****/\n\n    private _mountBoard (Board:SNS_Board|undefined):void {\n      if ((Board != null) && ((this as Component).base != null)) {\n        Board['_View'] = (this as Component).base\n        if (Board['_onMount'] != null) {\n          Board['_onMount']()\n        }\n      }\n      this._Board = Board\n    }\n\n  /**** _unmountBoard ****/\n\n    private _unmountBoard ():void {\n      const Board = this._Board\n      if (Board != null) {\n        Board['_View'] = undefined\n        if (Board['_onUnmount'] != null) {\n          Board['_onUnmount']()\n        }\n      }\n    }\n\n  /**** componentDidMount/WillUnmount ****/\n\n    public componentDidMount    ():void { this._mountBoard(this._Board) }\n    public componentWillUnmount ():void { this._unmountBoard() }\n\n  /**** rerender ****/\n\n    public rerender (Sticker?:SNS_Sticker):void {\n// @ts-ignore TS2339 \"Value\" is a valid property\n      (this as Component).setState({ Value:(this as Component).state.Value + 1 })\n    }\n\n  /**** render ****/\n\n    public render (PropSet:Indexable):any {\n      const my = this\n\n      let {\n        PUX,\n        Classes, Board, StickerList, Placeholder, Mode,\n        SelectionLimit, selectedStickers,\n        onSelectionChange, onStickerSelected, onStickerDeselected,\n        SelectionFrameStyle, SelectionHandleStyle,\n        LassoMode, onGeometryChange,\n        SnapToGrid, GridWidth, GridHeight,\n      } = PropSet\n\n      if (this._Board !== Board) {\n        this._unmountBoard()\n        this._mountBoard(Board)\n      }\n\n    /**** finishDraggingAndShaping ****/\n\n      function finishDraggingAndShaping ():void {\n        my._pointedSticker    = undefined\n        my._shapedStickers    = undefined\n        my._initialGeometries = undefined\n      }\n\n    /**** abortDraggingAndShaping ****/\n\n      function abortDraggingAndShaping ():void {\n        if (my._shapedStickers != null) {\n          changeGeometriesTo(my._shapedStickers,my._initialGeometries as SNS_Geometry[])\n        }\n        finishDraggingAndShaping()\n      }\n\n    /**** validate given properties ****/\n\n      allowTextline      ('board CSS class names',Classes)\n      allowBoard                         ('board',Board)\n      allowListSatisfying         ('sticker list',StickerList, ValueIsSticker)\n      allowTextline           ('placeholder text',Placeholder)\n      allowOneOf                    ('board mode',Mode, ['edit','run'])\n      allowOrdinal             ('selection limit',SelectionLimit)\n      allowListSatisfying('list of selected stickers',selectedStickers, ValueIsSticker)\n      allowFunction  ('selection change callback',onSelectionChange)\n      allowFunction         ('selection callback',onStickerSelected)\n      allowFunction       ('deselection callback',onStickerDeselected)\n      allowTextline  ('selection frame CSS style',SelectionFrameStyle)\n      allowText     ('selection handle CSS style',SelectionHandleStyle)\n      allowOneOf          ('lasso selection mode',LassoMode, ['touch','enclose'])\n      allowFunction   ('geometry change callback',onGeometryChange)\n      allowBoolean           ('\"SnapToGrid\" mode',SnapToGrid)\n      allowCardinal                 ('grid width',GridWidth)\n      allowCardinal                ('grid height',GridHeight)\n\n    /**** provide defaults for missing properties ****/\n\n      if (Classes              == null) { Classes               = '' }\n      if (Placeholder          == null) { Placeholder           = '(empty)' }\n      if (Mode                 == null) { Mode                  = 'run' }\n      if (SelectionLimit       == null) { SelectionLimit        = Infinity }\n      if (selectedStickers     == null) { selectedStickers      = [] }\n//    if (SelectionFrameStyle  == null) { SelectionFrameStyle   = 'dotted 2px orangered' }\n      if (SelectionHandleStyle == null) { SelectionHandleStyle  = 'background:orangered; border:solid 1px darkgray' }\n      if (LassoMode            == null) { LassoMode             = 'enclose' }\n      if (SnapToGrid           == null) { SnapToGrid            = false }\n      if (GridWidth            == null) { GridWidth             = 10 }\n      if (GridHeight           == null) { GridHeight            = 10 }\n\n    /**** sanitize Selections ****/\n\n      const selectedStickerSet:Set<SNS_Sticker> = new Set()\n        selectedStickers = selectedStickers.filter((selectedSticker:SNS_Sticker) => {\n          if (\n            ValueIsSticker(selectedSticker) &&\n            ! selectedStickerSet.has(selectedSticker)\n          ) {\n            selectedStickerSet.add(selectedSticker)\n            return true\n          } else {\n            abortDraggingAndShaping()\n            return false        // invalid selections don't invoke any callbacks\n          }\n        })\n      if (selectedStickers.length > SelectionLimit) {\n        selectStickers(selectedStickers.slice(0,SelectionLimit))\n      }\n\n     my._Mode = Mode\n\n      my._StickerList      = StickerList\n      my._selectedStickers = selectedStickers   // needed for dragging & shaping\n      my._SelectionLimit   = SelectionLimit                              // dto.\n\n      my._SnapToGrid = SnapToGrid                                        // dto.\n      my._GridWidth  = GridWidth                                         // dto.\n      my._GridHeight = GridHeight                                        // dto.\n\n    /**** Sticker Selection ****/\n\n      function selectStickers (\n        SelectionA:SNS_Sticker[], SelectionB:SNS_Sticker[] = []\n      ):void {\n        const newSelection:SNS_Sticker[] = SelectionA.slice()\n        SelectionB.forEach((Sticker:SNS_Sticker) => {\n          if (newSelection.indexOf(Sticker) < 0) { newSelection.push(Sticker) }\n        })\n\n        if (selectedStickers.length > my._SelectionLimit) {\n          newSelection.length = my._SelectionLimit\n        }\n\n        const StickersToSelect:SNS_Sticker[]   = []\n        const StickersToDeselect:SNS_Sticker[] = []\n          newSelection.forEach((Sticker:SNS_Sticker) => {\n            if (my._selectedStickers.indexOf(Sticker) < 0) {\n              StickersToSelect.push(Sticker)\n            }\n          })\n\n          my._selectedStickers.forEach((Sticker:SNS_Sticker) => {\n            if (newSelection.indexOf(Sticker) < 0) {\n              StickersToDeselect.push(Sticker)\n            }\n          })\n        selectedStickers = my._selectedStickers = newSelection\n\n        if ((StickersToSelect.length > 0) || (StickersToDeselect.length > 0)) {\n          abortDraggingAndShaping()\n\n          if (onSelectionChange != null) {\n            onSelectionChange(selectedStickers)\n          }\n        }\n\n        if ((StickersToDeselect.length > 0) && (onStickerDeselected != null)) {\n          StickersToDeselect.forEach((deselectedSticker:SNS_Sticker) => {\n            onStickerDeselected(deselectedSticker)\n          })\n        }\n\n        if ((StickersToSelect.length > 0) && (onStickerSelected != null)) {\n          StickersToSelect.forEach((selectedSticker:SNS_Sticker) => {\n            onStickerSelected(selectedSticker)\n          })\n        }\n      }\n\n      function StickerIsSelected (Sticker:SNS_Sticker):boolean {\n        return (my._selectedStickers.indexOf(Sticker) >= 0)\n      }\n\n    /**** Lasso Selection ****/\n\n      function GeometryOfLasso ():SNS_Geometry {\n        const { x:x0,y:y0 } = my._LassoStart as SNS_Position\n        const { x:x1,y:y1 } = my._LassoEnd || my._LassoStart as SNS_Position\n\n        let LassoX = (x0 <= x1 ? x0 : x1); let LassoWidth  = (x0 <= x1 ? x1-x0 : x0-x1)\n        let LassoY = (y0 <= y1 ? y0 : y1); let LassoHeight = (y0 <= y1 ? y1-y0 : y0-y1)\n\n        return { x:LassoX,y:LassoY, Width:LassoWidth,Height:LassoHeight }\n      }\n\n      function CSSGeometryOfLasso ():string {\n        const { x,y, Width,Height } = GeometryOfLasso()\n        return `left:${x}px; top:${y}px; width:${Width}px; height:${Height}px`\n      }\n\n      function StickersCaughtByLasso ():SNS_Sticker[] {\n        let { x:LassoX0,y:LassoY0, Width:LassoWidth,Height:LassoHeight } = GeometryOfLasso()\n        let LassoX1 = LassoX0+LassoWidth\n        let LassoY1 = LassoY0+LassoHeight\n\n        if (LassoMode === 'touch') {\n          return my._StickerList.filter((Sticker:SNS_Sticker) => {\n            if (! Sticker.isVisible || Sticker.isLocked) { return false }\n// @ts-ignore TS2339 strange: why does TS not recognize \"isSelectable\"?\n            if ((my._Mode === 'run') && ! Sticker.isSelectable) { return false }\n\n            const { x,y, Width,Height } = Sticker.Geometry\n            return (\n              (LassoX0 <= x+Width)  && (x <= LassoX1) &&\n              (LassoY0 <= y+Height) && (y <= LassoY1)\n            )\n          })\n        } else { // 'enclose'\n          return my._StickerList.filter((Sticker:SNS_Sticker) => {\n            if (! Sticker.isVisible || Sticker.isLocked) { return false }\n// @ts-ignore TS2339 strange: why does TS not recognize \"isSelectable\"?\n            if ((my._Mode === 'run') && ! Sticker.isSelectable) { return false }\n\n            const { x,y, Width,Height } = Sticker.Geometry\n            return (\n              (LassoX0 <= x) && (x+Width  <= LassoX1) &&\n              (LassoY0 <= y) && (y+Height <= LassoY1)\n            )\n          })\n        }\n      }\n\n      function dragLassoTo (\n        x:SNS_Location,y:SNS_Location, additiveSelection:boolean\n      ):void {\n        my._LassoEnd = { x,y }\n        selectStickers(\n          additiveSelection ? my._SelectionBeforeLasso : [], StickersCaughtByLasso()\n        )\n      }\n\n      function applyLasso ():void {\n        my._LassoStart = my._LassoEnd = undefined\n        my._SelectionBeforeLasso = []\n      }\n\n      function abortLasso ():void {\n        my._LassoStart = my._LassoEnd = undefined\n        selectStickers(my._SelectionBeforeLasso)\n        my._SelectionBeforeLasso = []\n      }\n\n    /**** Lasso Recognizer ****/\n\n      function onBoardClick ():void {\n        selectStickers([])\n      }\n\n      const LassoRecognizer = DragClickRecognizerFor(my._LassoRecognizerSlot, {\n        onlyFrom:     '.SNS.BoardView,.SNS.Sticker,.SNS.Sticker *',\n        neverFrom:    '.SNS.Sticker.selectable,.SNS.Sticker.selectable *',\n        Threshold:    4,\n        onDragStarted:(x:number,y:number, dx:number,dy:number, Event:PointerEvent) => {\n          my._SelectionBeforeLasso = my._selectedStickers.slice()\n\n// @ts-ignore TS2345 type casting is ok here\n          ;({ left:x,top:y } = fromDocumentTo('local',{ left:x,top:y },(my as Component).base))\n\n          my._LassoStart = { x,y }\n          dragLassoTo(x,y, Event.shiftKey || Event.metaKey)\n          my.rerender()\n        },\n        onDragContinued:(x:number,y:number, dx:number,dy:number, Event:PointerEvent) => {\n          dragLassoTo(\n// @ts-ignore TS2532 my._LassoStart is _not_ undefined\n            my._LassoStart.x+dx,my._LassoStart.y+dy,\n            Event.shiftKey || Event.metaKey\n          )\n          my.rerender()\n        },\n        onDragFinished: (x:number,y:number, dx:number,dy:number, Event:PointerEvent) => {\n          dragLassoTo(\n// @ts-ignore TS2532 my._LassoStart is _not_ undefined\n            my._LassoStart.x+dx,my._LassoStart.y+dy,\n            Event.shiftKey || Event.metaKey\n          )\n          applyLasso()\n          my.rerender()\n        },\n        onDragCancelled:(x:number,y:number, dx:number,dy:number) => {\n          abortLasso()\n          my.rerender()\n        },\n        onClicked:onBoardClick\n      })\n\n    /**** Geometry Handling ****/\n\n      function changeGeometriesTo (\n        StickerList:SNS_Sticker[], GeometryList:SNS_Geometry[]\n      ):void {\n        if (onGeometryChange != null) {\n          onGeometryChange(StickerList,GeometryList)\n          my.rerender()\n        }\n      }\n\n      function changeGeometriesBy (\n        StickerList:SNS_Sticker[], Mode:string, dx:number,dy:number,\n        initialGeometries?:SNS_Geometry[]\n      ):void {\n        if (onGeometryChange == null) { return }\n\n        let dX:number = 0, dY:number = 0, dW:number = 0, dH:number = 0\n        switch (Mode) {\n          case 'nw': dX = dx; dW = -dx; dY = dy; dH = -dy; break\n          case 'n':                     dY = dy; dH = -dy; break\n          case 'ne':          dW = dx;  dY = dy; dH = -dy; break\n          case 'e':           dW = dx;                     break\n          case 'se':          dW = dx;           dH = dy;  break\n          case 's':                              dH = dy;  break\n          case 'sw': dX = dx; dW = -dx;          dH = dy;  break\n          case 'w':  dX = dx; dW = -dx;                    break\n          case 'c':  dX = dx;           dY = dy;\n        }\n\n        if (initialGeometries == null) {\n          initialGeometries = my._initialGeometries as SNS_Geometry[]\n        }\n\n        const GeometryList = initialGeometries.map(\n          (Geometry:SNS_Geometry) => {\n            let Width:number  = Math.max(0,Geometry.Width+dW)\n            let Height:number = Math.max(0,Geometry.Height+dH)\n\n            let xl:number = Geometry.x+dX, xr = xl + Width\n            let yt:number = Geometry.y+dY, yb = yt + Height\n\n            if (my._SnapToGrid) {\n              let xl_ = my._GridWidth*Math.round(xl/my._GridWidth)\n              let xr_ = my._GridWidth*Math.round(xr/my._GridWidth)\n              let yt_ = my._GridHeight*Math.round(yt/my._GridHeight)\n              let yb_ = my._GridHeight*Math.round(yb/my._GridHeight)\n\n              switch (Mode) {\n                case 'nw': xl = Math.min(xl_,xr); yt = Math.min(yt_,yb); break\n                case 'n':                         yt = Math.min(yt_,yb); break\n                case 'ne': xr = Math.max(xl,xr_); yt = Math.min(yt_,yb); break\n                case 'e':  xr = Math.max(xl,xr_);                        break\n                case 'se': xr = Math.max(xl,xr_); yb = Math.max(yt,yb_); break\n                case 's':                         yb = Math.max(yt,yb_); break\n                case 'sw': xl = Math.min(xl_,xr); yb = Math.max(yt,yb_); break\n                case 'w':  xl = Math.min(xl_,xr);                        break\n                case 'c':  xl = xl_; xr = xl+Width; yt = yt_; yb = yt+Height\n              }\n            }\n            return { x:xl,y:yt, Width:xr-xl,Height:yb-yt }\n          }\n        )\n\n        changeGeometriesTo(StickerList,GeometryList)\n      }\n\n    /**** Sticker Drag/Select Recognizer ****/\n\n      const onStickerClick = (x:number,y:number, Event:PointerEvent) => {\n        if (SelectionLimit === 0) { return }\n\n        const Sticker = my._pointedSticker as SNS_Sticker\n\n        let SelectionChanged:boolean = false\n        let StickersToSelect:SNS_Sticker[], StickersToDeselect:SNS_Sticker[]\n        if (Event.shiftKey || Event.metaKey) { // additive/subtractive selection\n          SelectionChanged = true\n          if (StickerIsSelected(Sticker)) {\n            StickersToDeselect = [Sticker]\n            selectedStickers   = selectedStickers.filter(\n              (selectedSticker:SNS_Sticker) => (selectedSticker !== Sticker)\n            )\n          } else {\n            if (selectedStickers.length === SelectionLimit) {\n              StickersToDeselect = [selectedStickers.shift()]\n            }\n            StickersToSelect = [Sticker]\n            selectedStickers.push(Sticker)\n          }\n        } else {                                         // definitive selection\n          StickersToDeselect = selectedStickers.filter(\n            (selectedSticker:SNS_Sticker) => (selectedSticker !== Sticker)\n          )\n          SelectionChanged = ! StickerIsSelected(Sticker)\n          StickersToSelect  = (SelectionChanged ? [Sticker] : [])\n          selectedStickers  = [Sticker]\n        }\n\n        if (SelectionChanged && (onSelectionChange != null)) {\n          onSelectionChange(selectedStickers)\n        }\n\n// @ts-ignore TS2454 let's check IF variables were assigned\n        if ((StickersToDeselect != null) && (onStickerDeselected != null)) {\n          StickersToDeselect.forEach((deselectedSticker:SNS_Sticker) => {\n            onStickerDeselected(deselectedSticker)\n          })\n        }\n\n// @ts-ignore TS2454 let's check IF variables were assigned\n        if ((StickersToSelect != null) && (onStickerSelected != null)) {\n          StickersToSelect.forEach((selectedSticker:SNS_Sticker) => {\n            onStickerSelected(selectedSticker)\n          })\n        }\n\n        if (SelectionChanged) { my.rerender() }\n      }\n\n    /**** StickerRecognizer ****/\n\n      const StickerRecognizer = DragClickRecognizerFor(my._StickerRecognizerSlot, {\n        onlyFrom:     '.SNS.Cover',\n        Threshold:    4,\n        onDragStarted:(x:number,y:number, dx:number,dy:number, Event:PointerEvent) => {\n          if (! StickerIsSelected(my._pointedSticker as SNS_Sticker)) {\n            if (Event.shiftKey || Event.metaKey) {  // additive/subtractive sel.\n              selectStickers([my._pointedSticker as SNS_Sticker],my._selectedStickers)\n            } else {\n              selectStickers([my._pointedSticker as SNS_Sticker])\n            }\n          }\n\n          my._shapedStickers    = my._selectedStickers\n          my._initialGeometries = my._selectedStickers.map(\n            (Sticker:SNS_Sticker) => Sticker.Geometry\n          )\n          changeGeometriesBy(my._shapedStickers,'c', dx,dy)\n        },\n        onDragContinued:(x:number,y:number, dx:number,dy:number) => {\n          if (my._shapedStickers == null) { return }\n          changeGeometriesBy(my._shapedStickers,'c', dx,dy)\n        },\n        onDragFinished: (x:number,y:number, dx:number,dy:number) => {\n          if (my._shapedStickers == null) { return }\n\n          changeGeometriesBy(my._shapedStickers,'c', dx,dy)\n          finishDraggingAndShaping()\n        },\n        onDragCancelled:(x:number,y:number, dx:number,dy:number) => {\n          abortDraggingAndShaping()\n        },\n        onClicked:onStickerClick\n      })\n\n    /**** handleStickerEvent ****/\n\n      function handleStickerEvent (Event:PointerEvent, Sticker:SNS_Sticker):void {\n        my._ShapeMode      = 'c'\n        my._pointedSticker = Sticker\n        StickerRecognizer(Event)\n      }\n\n    /**** ShapeHandle Recognizer ****/\n\n      const ShapeHandleRecognizer = DragRecognizerFor(my._ShapeHandleRecognizerSlot, {\n        onlyFrom:     '.SNS.ShapeHandle',\n        Threshold:    0,\n        onDragStarted:(x:number,y:number, dx:number,dy:number) => {\n          my._shapedStickers    = my._selectedStickers\n          my._initialGeometries = my._selectedStickers.map(\n            (Sticker:SNS_Sticker) => Sticker.Geometry\n          )\n          changeGeometriesBy(my._shapedStickers, my._ShapeMode as string, dx,dy)\n        },\n        onDragContinued:(x:number,y:number, dx:number,dy:number) => {\n          if (my._shapedStickers == null) { return }\n          changeGeometriesBy(my._shapedStickers, my._ShapeMode as string, dx,dy)\n        },\n        onDragFinished: (x:number,y:number, dx:number,dy:number) => {\n          if (my._shapedStickers == null) { return }\n\n          changeGeometriesBy(my._shapedStickers, my._ShapeMode as string, dx,dy)\n          finishDraggingAndShaping()\n        },\n        onDragCancelled:(x:number,y:number, dx:number,dy:number) => {\n          abortDraggingAndShaping()\n        }\n      })\n\n      function handleShapeEvent (Event:PointerEvent, Mode:string):void {\n        my._ShapeMode = Mode\n        ShapeHandleRecognizer(Event)\n      }\n\n    /**** builtinSelectionFor ****/\n\n      function builtinSelectionFor (Sticker:SNS_Sticker):Function {\n        return function (Event:PointerEvent):void {\n          my._pointedSticker = Sticker\n          onStickerClick(0,0, Event)\n        }\n      }\n\n    /**** builtinDraggingFor ****/\n\n      const DragRecognizer:WeakMap<SNS_Sticker,Function> = new WeakMap()\n\n      function builtinDraggingFor (Sticker:SNS_Sticker):Function {\n        let Recognizer = DragRecognizer.get(Sticker)\n        if (Recognizer == null) {\n          DragRecognizer.set(Sticker, Recognizer = DragClickRecognizerFor(Sticker, {\n            onlyFrom:     '.builtinDraggable',\n            neverFrom:    '.notBuiltinDraggable',\n            Threshold:    4,\n            onDragStarted:(x:number,y:number, dx:number,dy:number, Event:PointerEvent) => {\n              my._pointedSticker = Sticker\n              if (! StickerIsSelected(my._pointedSticker as SNS_Sticker)) {\n                if (Event.shiftKey || Event.metaKey) {  // additive/subtractive sel.\n                  selectStickers([my._pointedSticker as SNS_Sticker],my._selectedStickers)\n                } else {\n                  selectStickers([my._pointedSticker as SNS_Sticker])\n                }\n              }\n\n              my._shapedStickers    = my._selectedStickers\n              my._initialGeometries = my._selectedStickers.map(\n                (Sticker:SNS_Sticker) => Sticker.Geometry\n              )\n              changeGeometriesBy(my._shapedStickers,'c', dx,dy)\n            },\n            onDragContinued:(x:number,y:number, dx:number,dy:number) => {\n              if (my._shapedStickers == null) { return }\n              changeGeometriesBy(my._shapedStickers,'c', dx,dy)\n            },\n            onDragFinished: (x:number,y:number, dx:number,dy:number) => {\n              if (my._shapedStickers == null) { return }\n\n              changeGeometriesBy(my._shapedStickers,'c', dx,dy)\n              finishDraggingAndShaping()\n            },\n            onDragCancelled:(x:number,y:number, dx:number,dy:number) => {\n              abortDraggingAndShaping()\n            },\n            onClicked:(x:number,y:number, Event:PointerEvent) => {\n              my._pointedSticker = Sticker\n              onStickerClick(0,0, Event)\n            }\n          }))\n        }\n        return Recognizer as Function\n      }\n\n    /**** horizontal Guides ****/\n\n      function horizontalGuides ():any {\n        if (my._shapedStickers == null) { return '' }\n\n        const EdgeSet:Indexable   = {}\n        const CenterSet:Indexable = {}\n        my._StickerList.filter(\n          (Sticker:SNS_Sticker) => ! StickerIsSelected(Sticker)\n        ).forEach((Sticker:SNS_Sticker) => {\n          const { y,Height } = Sticker.Geometry\n            const yt = Math.round(y)\n            const ym = Math.round(y+Height/2)\n            const yb = Math.round(y+Height)\n          EdgeSet[yt] = EdgeSet[yb] = true\n          CenterSet[ym] = true\n        })\n\n        const horizontalSet:Indexable = {}\n        my._shapedStickers.forEach((Sticker:SNS_Sticker) => {\n          const { y,Height } = Sticker.Geometry\n            const yt = Math.round(y)\n            const ym = Math.round(y+Height/2)\n            const yb = Math.round(y+Height)\n          if (EdgeSet[yt])                                     { horizontalSet[yt] = 'Edge' }\n          if (EdgeSet[ym]   && (horizontalSet[ym] !== 'Edge')) { horizontalSet[ym] = 'Center' }\n          if (EdgeSet[yb])                                     { horizontalSet[yb] = 'Edge' }\n          if (CenterSet[yt] && (horizontalSet[yt] !== 'Edge')) { horizontalSet[yt] = 'Center' }\n          if (CenterSet[ym] && (horizontalSet[ym] !== 'Edge')) { horizontalSet[ym] = 'Center' }\n          if (CenterSet[yb] && (horizontalSet[yb] !== 'Edge')) { horizontalSet[yb] = 'Center' }\n        })\n\n        const horizontalList:string[] = []\n          for (let y in horizontalSet) {\n            if (horizontalSet[y] != null) { horizontalList.push(y) }\n          }\n\n        return html`${horizontalList.map((y:string) => html`\n          <div class=\"SNS horizontalGuide ${horizontalSet[y]}\" style=\"top:${y}px\"/>\n        `)}`\n      }\n\n    /**** vertical Guides ****/\n\n      function verticalGuides ():any {\n        if (my._shapedStickers == null) { return '' }\n\n        const EdgeSet:Indexable   = {}\n        const CenterSet:Indexable = {}\n        my._StickerList.filter(\n          (Sticker:SNS_Sticker) => ! StickerIsSelected(Sticker)\n        ).forEach((Sticker:SNS_Sticker) => {\n          const { x,Width } = Sticker.Geometry\n            const xl = Math.round(x)\n            const xm = Math.round(x+Width/2)\n            const xr = Math.round(x+Width)\n          EdgeSet[xl] = EdgeSet[xr] = true\n          CenterSet[xm] = true\n        })\n\n        const verticalSet:Indexable = {}\n        my._shapedStickers.forEach((Sticker:SNS_Sticker) => {\n          const { x,Width } = Sticker.Geometry\n            const xl = Math.round(x)\n            const xm = Math.round(x+Width/2)\n            const xr = Math.round(x+Width)\n          if (EdgeSet[xl])                                   { verticalSet[xl] = 'Edge' }\n          if (EdgeSet[xm]   && (verticalSet[xm] !== 'Edge')) { verticalSet[xm] = 'Center' }\n          if (EdgeSet[xr])                                   { verticalSet[xr] = 'Edge' }\n          if (CenterSet[xl] && (verticalSet[xl] !== 'Edge')) { verticalSet[xl] = 'Center' }\n          if (CenterSet[xm] && (verticalSet[xm] !== 'Edge')) { verticalSet[xm] = 'Center' }\n          if (CenterSet[xr] && (verticalSet[xr] !== 'Edge')) { verticalSet[xr] = 'Center' }\n        })\n\n        const verticalList:string[] = []\n          for (let x in verticalSet) {\n            if (verticalSet[x] != null) { verticalList.push(x) }\n          }\n        return html`${verticalList.map((x:string) => html`\n          <div class=\"SNS verticalGuide ${verticalSet[x]}\" style=\"left:${x}px\"/>\n        `)}`\n      }\n\n    /**** actual rendering ****/\n\n      const BoardStyle = (Board == null ? undefined : CSSStyleOfVisual(Board))\n\n      return html`<div class=\"SNS BoardView ${Classes}\" style=${BoardStyle}\n        onPointerDown=${LassoRecognizer} onPointerMove=${LassoRecognizer}\n        onPointerUp=${LassoRecognizer} onPointerCancel=${LassoRecognizer}\n      >\n        ${Board == null\n          ? html`<div class=\"SNS Placeholder\"><div>(no Board to show)</div></div>`\n          : StickerList == null\n            ? html`<div class=\"SNS Placeholder\"><div>(no Stickers to show)</div></div>`\n            : StickerList.map((Sticker:SNS_Sticker) => {\n                if (! Sticker.isVisible) { return '' }\n\n                const Geometry   = Sticker.Geometry\n// @ts-ignore TS2339 strange: TS does not recognize \"isSelectable\"\n                const selectable = Sticker.isSelectable     // Mode-independent!\n                const selected   = StickerIsSelected(Sticker)\n\n                return html`<${SNS_StickerView} Sticker=${Sticker} key=${Sticker.Id}\n                  selected=${selected && (Mode === 'run')}\n                  SelectionFrameStyle=${SelectionFrameStyle}\n                  Geometry=${Geometry}\n                  selectable=${selectable}\n                  builtinDragging=${selectable && builtinDraggingFor(Sticker)}\n                  builtinSelection=${selectable &&builtinSelectionFor(Sticker)}\n                />`\n              })\n        }\n\n        ${(StickerList != null) && (Mode === 'edit')\n          ? StickerList.map((Sticker:SNS_Sticker) => {\n              if (! Sticker.isVisible) { return '' }\n\n              const selected = StickerIsSelected(Sticker)\n\n              return html`\n                <${SNS_Cover} Sticker=${Sticker} key=${Sticker.Id+'c'}\n                  selected=${selected}\n                  onPointerEvent=${(Event:PointerEvent) => handleStickerEvent(Event,Sticker)}\n                />\n              `\n            })\n          : ''\n        }\n\n        ${(selectedStickers.length > 0)\n          ? selectedStickers.filter(\n              (Sticker:SNS_Sticker) => Sticker.isVisible\n            ).map((Sticker:SNS_Sticker) => {\n              const Id       = Sticker.Id\n              const Geometry = Sticker.Geometry\n              return html`\n                <${SNS_ShapeHandle} key=${Id+'nw'} Mode=\"nw\" Geometry=${Geometry}\n                  onPointerEvent=${(Event:PointerEvent) => handleShapeEvent(Event,'nw')}/>\n                <${SNS_ShapeHandle} key=${Id+'n'}  Mode=\"n\"  Geometry=${Geometry}\n                  onPointerEvent=${(Event:PointerEvent) => handleShapeEvent(Event,'n')}/>\n                <${SNS_ShapeHandle} key=${Id+'ne'} Mode=\"ne\" Geometry=${Geometry}\n                  onPointerEvent=${(Event:PointerEvent) => handleShapeEvent(Event,'ne')}/>\n                <${SNS_ShapeHandle} key=${Id+'e'}  Mode=\"e\"  Geometry=${Geometry}\n                  onPointerEvent=${(Event:PointerEvent) => handleShapeEvent(Event,'e')}/>\n                <${SNS_ShapeHandle} key=${Id+'se'} Mode=\"se\" Geometry=${Geometry}\n                  onPointerEvent=${(Event:PointerEvent) => handleShapeEvent(Event,'se')}/>\n                <${SNS_ShapeHandle} key=${Id+'s'}  Mode=\"s\"  Geometry=${Geometry}\n                  onPointerEvent=${(Event:PointerEvent) => handleShapeEvent(Event,'s')}/>\n                <${SNS_ShapeHandle} key=${Id+'sw'} Mode=\"sw\" Geometry=${Geometry}\n                  onPointerEvent=${(Event:PointerEvent) => handleShapeEvent(Event,'sw')}/>\n                <${SNS_ShapeHandle} key=${Id+'w'}  Mode=\"w\"  Geometry=${Geometry}\n                  onPointerEvent=${(Event:PointerEvent) => handleShapeEvent(Event,'w')}/>\n              `\n            })\n          : ''\n        }\n        ${this._LassoStart == null\n          ? ''\n          : html`<div class=\"SNS Lasso\" style=${CSSGeometryOfLasso()}></>`\n        }\n        ${horizontalGuides()}\n        ${verticalGuides()}\n        ${Board == null\n          ? ''\n          : Board.DialogList.map((Dialog:SNS_Dialog) =>\n              html`<${SNS_DialogView} key=${Dialog.Id} PUX=${PUX} Board=${Board} Dialog=${Dialog}/>`\n            )\n        }\n      </div>`\n    }\n  }\n\n//------------------------------------------------------------------------------\n//--                             SNS_StickerView                              --\n//------------------------------------------------------------------------------\n\n  class SNS_StickerView extends Component {\n    private _Sticker:SNS_Sticker|undefined\n\n  /**** componentDidMount ****/\n\n    public componentDidMount ():void {\n      const Sticker = this._Sticker as SNS_Sticker\n\n      Sticker['_View'] = (this as Component).base\n      if (Sticker['_onMount'] != null) {\n        Sticker['_onMount']()\n      }\n    }\n\n  /**** componentWillUnmount ****/\n\n    public componentWillUnmount ():void {\n      const Sticker = this._Sticker as SNS_Sticker\n\n      Sticker['_View'] = undefined\n      if (Sticker['_onUnmount'] != null) {\n        Sticker['_onUnmount']()\n      }\n    }\n\n  /**** render ****/\n\n    public render (PropSet:Indexable):any {\n      let {\n        Sticker, selectable, selected, SelectionFrameStyle,\n        Geometry, builtinSelection, builtinDragging\n      } = PropSet\n\n      this._Sticker = Sticker\n\n      let { x,y, Width,Height } = Geometry\n        allowInteger('sticker x position',x)\n        allowInteger('sticker y position',y)\n        allowOrdinal     ('sticker width',Width)\n        allowOrdinal    ('sticker height',Height)\n      const CSSGeometry = (\n        (x != null) && (Width != null) && (y != null) && (Height != null)\n        ? `left:${x}px; top:${y}px; width:${Width}px; height:${Height}px; right:auto; bottom:auto;`\n        : ''\n      )\n\n      return html`<div class=\"\n        SNS Sticker ${selectable ? 'selectable' : ''} ${selected ? 'selected' : ''}\n      \" style=\"\n        ${CSSGeometry};\n        ${selected && (SelectionFrameStyle != null) ? `outline:${SelectionFrameStyle};` : ''}\n        ${CSSStyleOfVisual(Sticker) || ''}\n      \">\n        ${selectable\n          ? Sticker.Rendering({ builtinSelection,builtinDragging })\n          : Sticker.Rendering()\n        }\n      </div>`\n    }\n  }//------------------------------------------------------------------------------\n//--                                SNS_Cover                                 --\n//------------------------------------------------------------------------------\n\n  class SNS_Cover extends Component {\n    public render (PropSet:Indexable):any {\n      let { Sticker, onPointerEvent, ...otherProps } = PropSet\n\n      let { x,y, Width,Height } = Sticker.Geometry\n\n      const CSSGeometry = (\n        (x != null) && (Width != null) && (y != null) && (Height != null)\n        ? `left:${x}px; top:${y}px; width:${Width}px; height:${Height}px; right:auto; bottom:auto;`\n        : ''\n      )\n\n      return html`<div class=\"SNS Cover\" style=\"\n        ${CSSGeometry} ${Sticker.isLocked ? 'pointer-events:none' : ''}\n      \" ...${otherProps}\n        onPointerDown=${onPointerEvent} onPointerMove=${onPointerEvent}\n        onPointerUp=${onPointerEvent} onPointerCancel=${onPointerEvent}\n      />`\n    }\n  }\n\n//------------------------------------------------------------------------------\n//--                              SNS_DialogView                              --\n//------------------------------------------------------------------------------\n\n  const DefaultGeometry:SNS_Geometry = {\n    x:-Number.MAX_SAFE_INTEGER, Width:320,\n    y:-Number.MAX_SAFE_INTEGER, Height:240\n  }\n\n  class SNS_DialogView extends Component {\n    private _DragRecognizer:Function|undefined = undefined\n    private _Geometry:SNS_Geometry = DefaultGeometry // act., constrained dlg geo\n    private _DragMode:'drag'|'resize-sw'|'resize-s'|'resize-se'|undefined\n    private _DragOffset:SNS_Geometry = DefaultGeometry  // dlg geo at drag start\n\n    public state:Indexable = { Value:0 }\n\n    public rerender () {\n      (this as Component).setState({ Value:this.state.Value+1 })\n    }\n\n    public render (PropSet:Indexable):any {\n      const { PUX, Board, Dialog } = PropSet\n      if (Dialog.Visibility == false) { return '' }\n\n      let {\n        Id, Name, Title, isResizable, x, y, Width, Height,\n        minWidth, maxWidth, minHeight, maxHeight,\n        Renderer, onClose\n      } = Dialog\n\n      Width = Math.max(minWidth,Width)\n      if (maxWidth != null) { Width = Math.min(Width,maxWidth) }\n\n      Height = Math.max(minHeight,Height)\n      if (maxHeight != null) { Height = Math.min(Height,maxHeight) }\n\n      if (x == -Number.MAX_SAFE_INTEGER) { x = Math.max(0,(window.innerWidth-Width)/2) }\n      if (y == -Number.MAX_SAFE_INTEGER) { y = Math.max(0,(window.innerHeight-Height)/2) }\n\n      x = Math.min(x,window.innerWidth-40)\n      y = Math.max(0,Math.min(y,window.innerHeight-30))\n\n      const my = this, me = this; my._Geometry = { x,y, Width,Height }\n\n      const handleDrag = (x:number,y:number, dx:number,dy:number) => {\n        if (my._DragMode === 'drag') {\n          moveDialog(dx,dy)\n        } else {\n          resizeDialog(dx,dy)\n        }\n        Board.bringDialogToFront(Dialog.Name)\n        Board.rerender()\n      }\n\n      const moveDialog = (dx:number,dy:number) => {\n        Board.positionDialogAt(\n          Dialog.Name, my._DragOffset.x + dx,my._DragOffset.y + dy\n        )\n      }\n\n      const resizeDialog = (dx:number,dy:number) => {\n        let newWidth:number = my._DragOffset.Width\n        switch (my._DragMode) {\n          case 'resize-sw':\n            newWidth =  Math.max(minWidth,Math.min(my._DragOffset.Width-dx,maxWidth || Infinity))\n              dx = newWidth-my._DragOffset.Width\n            Board.positionDialogAt(\n              Dialog.Name, my._DragOffset.x-dx,my._DragOffset.y\n            )\n            newWidth = my._DragOffset.Width+dx\n            break\n          case 'resize-se':\n            newWidth = Math.max(minWidth,Math.min(my._DragOffset.Width+dx,maxWidth || Infinity))\n        }\n        let newHeight = Math.max(minHeight,Math.min(my._DragOffset.Height+dy,maxHeight || Infinity))\n        Board.sizeDialogTo(Dialog.Name, newWidth,newHeight)\n      }\n\n      let DragRecognizer = my._DragRecognizer\n      if (DragRecognizer == null) {\n        DragRecognizer = my._DragRecognizer = DragRecognizerFor(me, {\n          onlyFrom:       '.Titlebar,.leftResizer,.middleResizer,.rightResizer',\n          neverFrom:      '.CloseButton',\n          Threshold:      4,\n          onDragStarted:  (x:number,y:number, dx:number,dy:number, Event:PointerEvent) => {\n            let ClassList = (Event.target as HTMLElement).classList; my._DragMode = undefined\n            switch (true) {\n              case ClassList.contains('leftResizer'):   my._DragMode = 'resize-sw'; break\n              case ClassList.contains('middleResizer'): my._DragMode = 'resize-s';  break\n              case ClassList.contains('rightResizer'):  my._DragMode = 'resize-se'; break\n              default:                                  my._DragMode = 'drag'\n            }\n\n            my._DragOffset = { ...my._Geometry }\n            handleDrag(x,y, dx,dy)\n          },\n          onDragContinued: handleDrag,\n          onDragFinished:  handleDrag,\n          onDragCancelled: handleDrag,\n        })\n      }\n\n      function onCloseClick (Event:PointerEvent) {\n        Event.stopImmediatePropagation()\n        Event.preventDefault()\n\n        Board.closeDialog(Dialog.Name)\n        if (onClose != null) { onClose(Name) }\n      }\n\n\n\n      const CSSGeometry = (\n        `left:${x}px; top:${y}px; width:${Width}px; height:${Height}px; right:auto; bottom:auto;`\n      )\n\n      let Content\n      try {\n        Content = Renderer()\n      } catch (Signal) {\n        console.error('Dialog rendering failed',Signal)\n        Content = html`<div>(Dialog rendering failed)</div>`\n      }\n\n      return html`<div class=\"PUX ${isResizable ? 'Resizable' : ''}Dialog\" id=${Id} style=\"\n        position:fixed; ${CSSGeometry}\n      \">\n        <div class=\"ContentPane\">${Content}</div>\n\n        <div class=\"Titlebar\"\n          onPointerDown=${DragRecognizer} onPointerUp=${DragRecognizer}\n          onPointerMove=${DragRecognizer} onPointerCancel=${DragRecognizer}\n        >\n          <div class=\"Title\">${Title}</div>\n          <img class=\"CloseButton\" src=\"${PUX._ImageFolder}/xmark.png\"\n            onClick=${onCloseClick}/>\n        </div>\n\n        ${isResizable ? html`\n          <div class=\"leftResizer\"\n            onPointerDown=${DragRecognizer} onPointerUp=${DragRecognizer}\n            onPointerMove=${DragRecognizer} onPointerCancel=${DragRecognizer}\n          />\n          <div class=\"middleResizer\"\n            onPointerDown=${DragRecognizer} onPointerUp=${DragRecognizer}\n            onPointerMove=${DragRecognizer} onPointerCancel=${DragRecognizer}\n          />\n          <div class=\"rightResizer\"\n            onPointerDown=${DragRecognizer} onPointerUp=${DragRecognizer}\n            onPointerMove=${DragRecognizer} onPointerCancel=${DragRecognizer}\n          />\n        `: ''}\n      </>`\n    }\n  }\n\n//------------------------------------------------------------------------------\n//--                             SNS_ShapeHandle                              --\n//------------------------------------------------------------------------------\n\n  class SNS_ShapeHandle extends Component {\n    public render (PropSet:Indexable):any {\n      let { Mode, Geometry, onPointerEvent, ...otherProps } = PropSet\n\n      let { x,y, Width,Height } = Geometry\n      const xl = x-8, xm = Math.round(x+Width/2)-4,  xr = x+Width\n      const yt = y-8, ym = Math.round(y+Height/2)-4, yb = y+Height\n\n      let CSSGeometry, Cursor\n      switch (Mode) {\n        case 'nw': CSSGeometry = `left:${xl}px; top:${yt}px;`; Cursor = 'nwse'; break\n        case 'n':  CSSGeometry = `left:${xm}px; top:${yt}px;`; Cursor = 'ns';   break\n        case 'ne': CSSGeometry = `left:${xr}px; top:${yt}px;`; Cursor = 'nesw'; break\n        case 'e':  CSSGeometry = `left:${xr}px; top:${ym}px;`; Cursor = 'ew';   break\n        case 'se': CSSGeometry = `left:${xr}px; top:${yb}px;`; Cursor = 'nwse'; break\n        case 's':  CSSGeometry = `left:${xm}px; top:${yb}px;`; Cursor = 'ns';   break\n        case 'sw': CSSGeometry = `left:${xl}px; top:${yb}px;`; Cursor = 'nesw'; break\n        case 'w':  CSSGeometry = `left:${xl}px; top:${ym}px;`; Cursor = 'ew';   break\n      }\n      Cursor = 'cursor:' + Cursor + '-resize'\n\n      return html`<div class=\"SNS ShapeHandle\" style=\"${CSSGeometry} ${Cursor}\" ...${otherProps}\n        onPointerDown=${onPointerEvent} onPointerMove=${onPointerEvent}\n        onPointerUp=${onPointerEvent} onPointerCancel=${onPointerEvent}\n      />`\n    }\n  }\n\n// @ts-ignore TS2339 allow global variable \"SNS_BoardView\"\n  window.SNS_BoardView = SNS_BoardView\n\n  document.dispatchEvent(\n// @ts-ignore TS2339 allow global variable \"SNS_BoardView\"\n    new CustomEvent('SNS_BoardView',{ detail:window.SNS_BoardView })\n  )\n"],"names":["fromDocumentTo","Conversion","Stylesheet","document","createElement","setAttribute","innerHTML","head","appendChild","SNS_BoardView","_Component","_len","_this","arguments","length","args","Array","_key","call","apply","this","concat","_Board","_Mode","_StickerList","_pointedSticker","_selectedStickers","_SelectionLimit","Infinity","_LassoStart","_LassoEnd","_SelectionBeforeLasso","_ShapeMode","_shapedStickers","_initialGeometries","_SnapToGrid","_GridWidth","_GridHeight","_StickerRecognizerSlot","_ShapeHandleRecognizerSlot","_LassoRecognizerSlot","state","Value","_inheritsLoose","_proto","prototype","_mountBoard","Board","base","_unmountBoard","undefined","componentDidMount","componentWillUnmount","rerender","Sticker","setState","render","PropSet","my","PUX","Classes","StickerList","Placeholder","Mode","SelectionLimit","selectedStickers","onSelectionChange","onStickerSelected","onStickerDeselected","SelectionFrameStyle","SelectionHandleStyle","LassoMode","onGeometryChange","SnapToGrid","GridWidth","GridHeight","finishDraggingAndShaping","abortDraggingAndShaping","changeGeometriesTo","allowTextline","allowBoard","allowListSatisfying","ValueIsSticker","allowOneOf","allowOrdinal","allowFunction","allowText","allowBoolean","allowCardinal","selectedStickerSet","Set","selectStickers","SelectionA","SelectionB","newSelection","slice","forEach","indexOf","push","StickersToSelect","StickersToDeselect","deselectedSticker","selectedSticker","StickerIsSelected","GeometryOfLasso","_my$_LassoStart","x0","x","y0","y","_ref","x1","y1","Width","Height","dragLassoTo","additiveSelection","_GeometryOfLasso2","LassoX0","LassoY0","LassoX1","LassoY1","filter","isVisible","isLocked","isSelectable","_Sticker$Geometry","Geometry","_Sticker$Geometry2","has","add","LassoRecognizer","DragClickRecognizerFor","onlyFrom","neverFrom","Threshold","onDragStarted","dx","dy","Event","_fromDocumentTo","left","top","shiftKey","metaKey","onDragContinued","onDragFinished","onDragCancelled","onClicked","GeometryList","changeGeometriesBy","initialGeometries","dX","dY","dW","dH","map","Math","max","xl","xr","yt","yb","xl_","round","xr_","yt_","yb_","min","onStickerClick","SelectionChanged","shift","StickerRecognizer","ShapeHandleRecognizer","DragRecognizerFor","handleShapeEvent","_GeometryOfLasso","DragRecognizer","WeakMap","BoardStyle","CSSStyleOfVisual","html","_templateObject5","_taggedTemplateLiteralLoose","_templateObject6","_templateObject7","selectable","selected","_templateObject8","SNS_StickerView","Id","Recognizer","get","set","builtinDraggingFor","builtinSelectionFor","_templateObject9","SNS_Cover","handleStickerEvent","_templateObject10","SNS_ShapeHandle","_templateObject11","CSSGeometryOfLasso","EdgeSet","CenterSet","_Sticker$Geometry3","ym","horizontalSet","_Sticker$Geometry4","horizontalList","_templateObject","_templateObject2","horizontalGuides","_Sticker$Geometry5","xm","verticalSet","_Sticker$Geometry6","verticalList","_templateObject3","_templateObject4","verticalGuides","DialogList","Dialog","_templateObject12","SNS_DialogView","Component","_Component2","_len2","_this2","_key2","_Sticker","_proto2","builtinSelection","builtinDragging","allowInteger","CSSGeometry","_templateObject13","Rendering","_Component3","onPointerEvent","otherProps","_objectWithoutPropertiesLoose","_excluded","_Sticker$Geometry7","_templateObject14","DefaultGeometry","Number","MAX_SAFE_INTEGER","_Component4","_this3","_len3","_key3","_DragRecognizer","_Geometry","_DragMode","_DragOffset","_proto4","Visibility","Name","Title","isResizable","minWidth","maxWidth","minHeight","maxHeight","Renderer","onClose","window","innerWidth","innerHeight","handleDrag","moveDialog","resizeDialog","bringDialogToFront","positionDialogAt","newWidth","newHeight","sizeDialogTo","ClassList","target","classList","contains","_extends","Content","Signal","console","error","_templateObject15","_templateObject16","_ImageFolder","stopImmediatePropagation","preventDefault","closeDialog","_templateObject17","_Component5","Cursor","_excluded2","_templateObject18","dispatchEvent","CustomEvent","detail"],"mappings":"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"}