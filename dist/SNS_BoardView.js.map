{"version":3,"file":"SNS_BoardView.js","sources":["../node_modules/htm/preact/index.module.js","../src/SNS_BoardView.ts"],"sourcesContent":["import{h as r,Component as o,render as t}from\"preact\";export{h,render,Component}from\"preact\";import e from\"htm\";var m=e.bind(r);export{m as html};\n","/*******************************************************************************\n*                                                                              *\n*                BoardView for \"Shareable Note Stickers\" (SNS)                 *\n*                                                                              *\n*******************************************************************************/\n\n  import {\n    allowBoolean,\n    allowInteger, allowOrdinal, allowCardinal,\n    allowText, allowTextline,\n    allowFunction,\n    allowListSatisfying,\n    allowOneOf,\n  } from 'javascript-interface-library'\n\n  import {\n    SNS_Board, SNS_Sticker,\n    ValueIsSticker,\n    allowBoard,\n    CSSStyleOfVisual,\n  } from 'shareable-note-stickers'\n\n  import Conversion from 'svelte-coordinate-conversion'\n  const { fromDocumentTo } = Conversion\n\n  import { html, Component } from 'htm/preact'\n\n// @ts-ignore TS7016 *C* sometimes, I hate package management\n  import { DragRecognizerFor, DragClickRecognizerFor } from 'protoux'\n\n/**** install stylesheet for this BoardView ****/\n\n  const Stylesheet = document.createElement('style')\n    Stylesheet.setAttribute('id','SNS Stylesheet')\n    Stylesheet.innerHTML = `/*******************************************************************************\n*                                                                              *\n*                        Shareable Note Stickers (SNS)                         *\n*                                                                              *\n*******************************************************************************/\n\n/**** all SNS elements are absolutely positioned ****/\n\n  .SNS {\n    display:block; position:absolute;\n    margin:0px; padding:0px;\n    background:none; border:none; border-radius:0px; outline:none;\n  }\n\n/**** Error Indicator ****/\n\n  .SNS.ErrorIndicator {\n    overflow:hidden;\n    left:0px; top:0px; width:24px; height:24px;\n    background:url(\"data:image/svg+xml,%3C%3Fxml version='1.0' encoding='utf-8'%3F%3E%3Csvg width='24px' height='24px' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M12 17.0001H12.01M12 10.0001V14.0001M6.41209 21.0001H17.588C19.3696 21.0001 20.2604 21.0001 20.783 20.6254C21.2389 20.2985 21.5365 19.7951 21.6033 19.238C21.6798 18.5996 21.2505 17.819 20.3918 16.2579L14.8039 6.09805C13.8897 4.4359 13.4326 3.60482 12.8286 3.32987C12.3022 3.09024 11.6978 3.09024 11.1714 3.32987C10.5674 3.60482 10.1103 4.4359 9.19614 6.09805L3.6082 16.2579C2.74959 17.819 2.32028 18.5996 2.39677 19.238C2.46351 19.7951 2.76116 20.2985 3.21709 20.6254C3.7396 21.0001 4.63043 21.0001 6.41209 21.0001Z' stroke='orange' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' fill='white'/%3E%3C/svg%3E\");\n    pointer-events:auto;\n  }\n\n\n/**** BoardView ****/\n\n  .SNS.BoardView {\n    left:0px; top:0px; right:0px; bottom:0px;\n  }\n\n/**** Sticker and Contents, Cover ****/\n\n  .SNS.Sticker {}\n  .SNS.Sticker > .SNS {\n    display:block; position:absolute;\n    left:0px; top:0px; width:100%; height:100%; right:auto; bottom:auto;\n  }\n\n  .SNS.Cover { user-select:none; z-index:1000000 }\n\n/**** Selection Markers ****/\n\n  .SNS.Sticker.selected, .SNS.Cover[selected] {\n    outline:dotted 2px orangered;\n  }\n\n  .SNS.ShapeHandle {\n    width:8px; height:8px;\n    background:orangered; border:solid 1px darkgray;\n    z-index:1000001; /* above .SNS.Cover */\n  }\n\n/**** Selection Lasso ****/\n\n  .SNS.Lasso {\n    background:rgba(255,69,0, 0.1); /* border:dashed 2px orangered; */\n  }\n\n/**** Dragging Guides ****/\n\n  .SNS.horizontalGuide.Edge {\n    left:0px; right:0px; height:1px;\n    border-top:dashed 1px orangered;\n  }\n  .SNS.verticalGuide.Edge {\n    top:0px; bottom:0px; width:1px;\n    border-left:dashed 1px orangered;\n  }\n\n  .SNS.horizontalGuide.Center {\n    left:0px; right:0px; height:1px;\n    border-top:dotted 1px orangered;\n  }\n  .SNS.verticalGuide.Center {\n    top:0px; bottom:0px; width:1px;\n    border-left:dotted 1px orangered;\n  }\n\n/**** Placeholder ****/\n\n  .SNS.Placeholder {\n    display:block; position:relative;\n    width:100%; height:100%;\n  }\n\n  .SNS.Placeholder > * {\n    display:block; position:absolute;\n    left:50%; top:50%;\n    transform:translate(-55%,-50%);\n    white-space:nowrap;\n  }\n\n`\n  document.head.appendChild(Stylesheet)\n\n/**** make some existing types indexable ****/\n\n  interface Indexable { [Key:string]:any }\n\n//------------------------------------------------------------------------------\n//--                             Type Definitions                             --\n//------------------------------------------------------------------------------\n\n/**** geometry-related types ****/\n\n  export type SNS_Location  = number         // mainly for illustrative purposes\n  export type SNS_Dimension = number                                     // dto.\n  export type SNS_Position  = { x:SNS_Location,y:SNS_Location }\n  export type SNS_Size      = { Width:SNS_Dimension,Height:SNS_Dimension }\n  export type SNS_Geometry  = { x:SNS_Location,y:SNS_Location, Width:SNS_Dimension,Height:SNS_Dimension }\n\n//------------------------------------------------------------------------------\n//--                              SNS_BoardView                               --\n//------------------------------------------------------------------------------\n\n  export class SNS_BoardView extends Component {\n    private _Board:SNS_Board|undefined\n\n    private _StickerList:SNS_Sticker[] = []\n    private _pointedSticker:SNS_Sticker|undefined\n    private _selectedStickers:SNS_Sticker[] = []       // for dragging & shaping\n    private _SelectionLimit:number = Infinity\n\n    private _LassoStart:SNS_Position|undefined\n    private _LassoEnd:SNS_Position|undefined\n    private _SelectionBeforeLasso:SNS_Sticker[] = []\n\n    private _ShapeMode:string|undefined\n    private _shapedStickers:SNS_Sticker[]|undefined\n    private _initialGeometries:SNS_Geometry[]|undefined\n\n    private _SnapToGrid:boolean = false\n    private _GridWidth:number   = 1\n    private _GridHeight:number  = 1\n\n    private _StickerRecognizerSlot = {}\n    private _ShapeHandleRecognizerSlot = {}\n    private _LassoRecognizerSlot = {}\n\n    public state:Indexable = { Value:0 }\n\n  /**** _mountBoard ****/\n\n    private _mountBoard (Board:SNS_Board|undefined):void {\n      if ((Board != null) && ((this as Component).base != null)) {\n        Board['_View'] = (this as Component).base\n        if (Board['_onMount'] != null) {\n          Board['_onMount']()\n        }\n      }\n      this._Board = Board\n    }\n\n  /**** _unmountBoard ****/\n\n    private _unmountBoard ():void {\n      const Board = this._Board\n      if (Board != null) {\n        Board['_View'] = undefined\n        if (Board['_onUnmount'] != null) {\n          Board['_onUnmount']()\n        }\n      }\n    }\n\n  /**** componentDidMount/WillUnmount ****/\n\n    public componentDidMount    ():void { this._mountBoard(this._Board) }\n    public componentWillUnmount ():void { this._unmountBoard() }\n\n  /**** rerender ****/\n\n    public rerender ():void {\n// @ts-ignore TS2339 \"Value\" is a valid property\n      (this as Component).setState({ Value:(this as Component).state.Value + 1 })\n    }\n\n  /**** render ****/\n\n    public render (PropSet:Indexable):any {\n      const my = this\n\n      let {\n        Classes, Board, StickerList, Placeholder, Mode,\n        SelectionLimit, selectedStickers,\n        onSelectionChange, onStickerSelected, onStickerDeselected,\n        SelectionFrameStyle, SelectionHandleStyle,\n        LassoMode, onGeometryChange,\n        SnapToGrid, GridWidth, GridHeight,\n      } = PropSet\n\n      if (this._Board !== Board) {\n        this._unmountBoard()\n        this._mountBoard(Board)\n      }\n\n    /**** finishDraggingAndShaping ****/\n\n      function finishDraggingAndShaping ():void {\n        my._pointedSticker    = undefined\n        my._shapedStickers    = undefined\n        my._initialGeometries = undefined\n      }\n\n    /**** abortDraggingAndShaping ****/\n\n      function abortDraggingAndShaping ():void {\n        if (my._shapedStickers != null) {\n          changeGeometriesTo(my._shapedStickers,my._initialGeometries as SNS_Geometry[])\n        }\n        finishDraggingAndShaping()\n      }\n\n    /**** validate given properties ****/\n\n      allowTextline      ('board CSS class names',Classes)\n      allowBoard                         ('board',Board)\n      allowListSatisfying         ('sticker list',StickerList, ValueIsSticker)\n      allowTextline           ('placeholder text',Placeholder)\n      allowOneOf                    ('board mode',Mode, ['edit','run'])\n      allowOrdinal             ('selection limit',SelectionLimit)\n      allowListSatisfying('list of selected stickers',selectedStickers, ValueIsSticker)\n      allowFunction  ('selection change callback',onSelectionChange)\n      allowFunction         ('selection callback',onStickerSelected)\n      allowFunction       ('deselection callback',onStickerDeselected)\n      allowTextline  ('selection frame CSS style',SelectionFrameStyle)\n      allowText     ('selection handle CSS style',SelectionHandleStyle)\n      allowOneOf          ('lasso selection mode',LassoMode, ['touch','contain'])\n      allowFunction   ('geometry change callback',onGeometryChange)\n      allowBoolean           ('\"SnapToGrid\" mode',SnapToGrid)\n      allowCardinal                 ('grid width',GridWidth)\n      allowCardinal                ('grid height',GridHeight)\n\n    /**** provide defaults for missing properties ****/\n\n      if (Classes              == null) { Classes               = '' }\n      if (Placeholder          == null) { Placeholder           = '(empty)' }\n      if (Mode                 == null) { Mode                  = 'run' }\n      if (SelectionLimit       == null) { SelectionLimit        = Infinity }\n      if (selectedStickers     == null) { selectedStickers      = [] }\n//    if (SelectionFrameStyle  == null) { SelectionFrameStyle   = 'dotted 2px orangered' }\n      if (SelectionHandleStyle == null) { SelectionHandleStyle  = 'background:orangered; border:solid 1px darkgray' }\n      if (LassoMode            == null) { LassoMode             = 'contain' }\n      if (SnapToGrid           == null) { SnapToGrid            = false }\n      if (GridWidth            == null) { GridWidth             = 10 }\n      if (GridHeight           == null) { GridHeight            = 10 }\n\n    /**** sanitize Selections ****/\n\n      const selectedStickerSet:Set<SNS_Sticker> = new Set()\n        selectedStickers = selectedStickers.filter((selectedSticker:SNS_Sticker) => {\n          if (\n            ValueIsSticker(selectedSticker) &&\n            ! selectedStickerSet.has(selectedSticker)\n          ) {\n            selectedStickerSet.add(selectedSticker)\n            return true\n          } else {\n            abortDraggingAndShaping()\n            return false        // invalid selections don't invoke any callbacks\n          }\n        })\n      if (selectedStickers.length > SelectionLimit) {\n        selectStickers(selectedStickers.slice(0,SelectionLimit))\n      }\n\n      my._StickerList      = StickerList\n      my._selectedStickers = selectedStickers   // needed for dragging & shaping\n      my._SelectionLimit   = SelectionLimit                              // dto.\n\n      my._SnapToGrid = SnapToGrid                                        // dto.\n      my._GridWidth  = GridWidth                                         // dto.\n      my._GridHeight = GridHeight                                        // dto.\n\n    /**** Sticker Selection ****/\n\n      function selectStickers (\n        SelectionA:SNS_Sticker[], SelectionB:SNS_Sticker[] = []\n      ):void {\n        const newSelection:SNS_Sticker[] = SelectionA.slice()\n        SelectionB.forEach((Sticker:SNS_Sticker) => {\n          if (newSelection.indexOf(Sticker) < 0) { newSelection.push(Sticker) }\n        })\n\n        if (selectedStickers.length > my._SelectionLimit) {\n          newSelection.length = my._SelectionLimit\n        }\n\n        const StickersToSelect:SNS_Sticker[]   = []\n        const StickersToDeselect:SNS_Sticker[] = []\n          newSelection.forEach((Sticker:SNS_Sticker) => {\n            if (my._selectedStickers.indexOf(Sticker) < 0) {\n              StickersToSelect.push(Sticker)\n            }\n          })\n\n          my._selectedStickers.forEach((Sticker:SNS_Sticker) => {\n            if (newSelection.indexOf(Sticker) < 0) {\n              StickersToDeselect.push(Sticker)\n            }\n          })\n        selectedStickers = my._selectedStickers = newSelection\n\n        if ((StickersToSelect.length > 0) || (StickersToDeselect.length > 0)) {\n          abortDraggingAndShaping()\n\n          if (onSelectionChange != null) {\n            onSelectionChange(selectedStickers)\n          }\n        }\n\n        if ((StickersToDeselect.length > 0) && (onStickerDeselected != null)) {\n          StickersToDeselect.forEach((deselectedSticker:SNS_Sticker) => {\n            onStickerDeselected(deselectedSticker)\n          })\n        }\n\n        if ((StickersToSelect.length > 0) && (onStickerSelected != null)) {\n          StickersToSelect.forEach((selectedSticker:SNS_Sticker) => {\n            onStickerSelected(selectedSticker)\n          })\n        }\n      }\n\n      function StickerIsSelected (Sticker:SNS_Sticker):boolean {\n        return (selectedStickers.indexOf(Sticker) >= 0)\n      }\n\n    /**** Lasso Selection ****/\n\n      function GeometryOfLasso ():SNS_Geometry {\n        const { x:x0,y:y0 } = my._LassoStart as SNS_Position\n        const { x:x1,y:y1 } = my._LassoEnd || my._LassoStart as SNS_Position\n\n        let LassoX = (x0 <= x1 ? x0 : x1); let LassoWidth  = (x0 <= x1 ? x1-x0 : x0-x1)\n        let LassoY = (y0 <= y1 ? y0 : y1); let LassoHeight = (y0 <= y1 ? y1-y0 : y0-y1)\n\n        return { x:LassoX,y:LassoY, Width:LassoWidth,Height:LassoHeight }\n      }\n\n      function CSSGeometryOfLasso ():string {\n        const { x,y, Width,Height } = GeometryOfLasso()\n        return `left:${x}px; top:${y}px; width:${Width}px; height:${Height}px`\n      }\n\n      function StickersCaughtByLasso ():SNS_Sticker[] {\n        let { x:LassoX0,y:LassoY0, Width:LassoWidth,Height:LassoHeight } = GeometryOfLasso()\n        let LassoX1 = LassoX0+LassoWidth\n        let LassoY1 = LassoY0+LassoHeight\n\n        if (LassoMode === 'touch') {\n          return my._StickerList.filter((Sticker:SNS_Sticker) => {\n            if (! Sticker.isVisible || Sticker.isLocked) { return false }\n\n            const { x,y, Width,Height } = Sticker.Geometry\n            return (\n              (LassoX0 <= x+Width)  && (x <= LassoX1) &&\n              (LassoY0 <= y+Height) && (y <= LassoY1)\n            )\n          })\n        } else { // 'enclose'\n          return my._StickerList.filter((Sticker:SNS_Sticker) => {\n            if (! Sticker.isVisible || Sticker.isLocked) { return false }\n\n            const { x,y, Width,Height } = Sticker.Geometry\n            return (\n              (LassoX0 <= x) && (x <= LassoX1+Width) &&\n              (LassoY0 <= y) && (y <= LassoY1+Height)\n            )\n          })\n        }\n      }\n\n      function dragLassoTo (x:SNS_Location,y:SNS_Location):void {\n        my._LassoEnd = { x,y }\n        selectStickers(my._SelectionBeforeLasso, StickersCaughtByLasso())\n      }\n\n      function applyLasso ():void {\n        my._LassoStart = my._LassoEnd = undefined\n        my._SelectionBeforeLasso = []\n      }\n\n      function abortLasso ():void {\n        my._LassoStart = my._LassoEnd = undefined\n        selectStickers(my._SelectionBeforeLasso)\n        my._SelectionBeforeLasso = []\n      }\n\n    /**** Lasso Recognizer ****/\n\n      function onBoardClick ():void {\n        selectStickers([])\n      }\n\n      const LassoRecognizer = DragClickRecognizerFor(my._LassoRecognizerSlot, {\n        onlyFrom:     '.SNS.BoardView',\n        Threshold:    4,\n        onDragStarted:(x:number,y:number, dx:number,dy:number) => {\n          my._SelectionBeforeLasso = selectedStickers.slice()\n\n// @ts-ignore TS2345 type casting is ok here\n          ;({ left:x,top:y } = fromDocumentTo('local',{ left:x,top:y },(my as Component).base))\n\n          my._LassoStart = { x,y }\n          dragLassoTo(x,y)\n          my.rerender()\n        },\n        onDragContinued:(x:number,y:number, dx:number,dy:number) => {\n// @ts-ignore TS2532 my._LassoStart is _not_ undefined\n          dragLassoTo(my._LassoStart.x+dx,my._LassoStart.y+dy)\n          my.rerender()\n        },\n        onDragFinished: (x:number,y:number, dx:number,dy:number) => {\n// @ts-ignore TS2532 my._LassoStart is _not_ undefined\n          dragLassoTo(my._LassoStart.x+dx,my._LassoStart.y+dy)\n          applyLasso()\n          my.rerender()\n        },\n        onDragCancelled:(x:number,y:number, dx:number,dy:number) => {\n          abortLasso()\n          my.rerender()\n        },\n        onClicked:onBoardClick\n      })\n\n    /**** Geometry Handling ****/\n\n      function changeGeometriesTo (\n        StickerList:SNS_Sticker[], GeometryList:SNS_Geometry[]\n      ):void {\n        if (onGeometryChange != null) {\n          onGeometryChange(StickerList,GeometryList)\n          my.rerender()\n        }\n      }\n\n      function changeGeometriesBy (\n        StickerList:SNS_Sticker[], Mode:string, dx:number,dy:number,\n        initialGeometries?:SNS_Geometry[]\n      ):void {\n        if (onGeometryChange == null) { return }\n\n        let dX:number = 0, dY:number = 0, dW:number = 0, dH:number = 0\n        switch (Mode) {\n          case 'nw': dX = dx; dW = -dx; dY = dy; dH = -dy; break\n          case 'n':                     dY = dy; dH = -dy; break\n          case 'ne':          dW = dx;  dY = dy; dH = -dy; break\n          case 'e':           dW = dx;                     break\n          case 'se':          dW = dx;           dH = dy;  break\n          case 's':                              dH = dy;  break\n          case 'sw': dX = dx; dW = -dx;          dH = dy;  break\n          case 'w':  dX = dx; dW = -dx;                    break\n          case 'c':  dX = dx;           dY = dy;\n        }\n\n        if (initialGeometries == null) {\n          initialGeometries = my._initialGeometries as SNS_Geometry[]\n        }\n\n        const GeometryList = initialGeometries.map(\n          (Geometry:SNS_Geometry) => {\n            let Width:number  = Math.max(0,Geometry.Width+dW)\n            let Height:number = Math.max(0,Geometry.Height+dH)\n\n            let xl:number = Geometry.x+dX, xr = xl + Width\n            let yt:number = Geometry.y+dY, yb = yt + Height\n\n            if (my._SnapToGrid) {\n              let xl_ = my._GridWidth*Math.round(xl/my._GridWidth)\n              let xr_ = my._GridWidth*Math.round(xr/my._GridWidth)\n              let yt_ = my._GridHeight*Math.round(yt/my._GridHeight)\n              let yb_ = my._GridHeight*Math.round(yb/my._GridHeight)\n\n              switch (Mode) {\n                case 'nw': xl = Math.min(xl_,xr); yt = Math.min(yt_,yb); break\n                case 'n':                         yt = Math.min(yt_,yb); break\n                case 'ne': xr = Math.max(xl,xr_); yt = Math.min(yt_,yb); break\n                case 'e':  xr = Math.max(xl,xr_);                        break\n                case 'se': xr = Math.max(xl,xr_); yb = Math.max(yt,yb_); break\n                case 's':                         yb = Math.max(yt,yb_); break\n                case 'sw': xl = Math.min(xl_,xr); yb = Math.max(yt,yb_); break\n                case 'w':  xl = Math.min(xl_,xr);                        break\n                case 'c':  xl = xl_; xr = xl+Width; yt = yt_; yb = yt+Height\n              }\n            }\n            return { x:xl,y:yt, Width:xr-xl,Height:yb-yt }\n          }\n        )\n\n        changeGeometriesTo(StickerList,GeometryList)\n      }\n\n    /**** Sticker Drag/Select Recognizer ****/\n\n      const onStickerClick = (x:number,y:number, Event:PointerEvent) => {\n        if (SelectionLimit === 0) { return }\n\n        const Sticker = my._pointedSticker as SNS_Sticker\n\n        let SelectionChanged:boolean = false\n        let StickersToSelect:SNS_Sticker[], StickersToDeselect:SNS_Sticker[]\n        if (Event.shiftKey || Event.metaKey) { // additive/subtractive selection\n          SelectionChanged = true\n          if (StickerIsSelected(Sticker)) {\n            StickersToDeselect = [Sticker]\n            selectedStickers   = selectedStickers.filter(\n              (selectedSticker:SNS_Sticker) => (selectedSticker !== Sticker)\n            )\n          } else {\n            if (selectedStickers.length === SelectionLimit) {\n              StickersToDeselect = [selectedStickers.shift()]\n            }\n            StickersToSelect = [Sticker]\n            selectedStickers.push(Sticker)\n          }\n        } else {                                         // definitive selection\n          StickersToDeselect = selectedStickers.filter(\n            (selectedSticker:SNS_Sticker) => (selectedSticker !== Sticker)\n          )\n          SelectionChanged = ! StickerIsSelected(Sticker)\n          StickersToSelect  = (SelectionChanged ? [Sticker] : [])\n          selectedStickers  = [Sticker]\n        }\n\n        if (SelectionChanged && (onSelectionChange != null)) {\n          onSelectionChange(selectedStickers)\n        }\n\n// @ts-ignore TS2454 let's check IF variables were assigned\n        if ((StickersToDeselect != null) && (onStickerDeselected != null)) {\n          StickersToDeselect.forEach((deselectedSticker:SNS_Sticker) => {\n            onStickerDeselected(deselectedSticker)\n          })\n        }\n\n// @ts-ignore TS2454 let's check IF variables were assigned\n        if ((StickersToSelect != null) && (onStickerSelected != null)) {\n          StickersToSelect.forEach((selectedSticker:SNS_Sticker) => {\n            onStickerSelected(selectedSticker)\n          })\n        }\n\n        if (SelectionChanged) { my.rerender() }\n      }\n\n    /**** StickerRecognizer ****/\n\n      const StickerRecognizer = DragClickRecognizerFor(my._StickerRecognizerSlot, {\n        onlyFrom:     '.SNS.Cover',\n        Threshold:    4,\n        onDragStarted:(x:number,y:number, dx:number,dy:number, Event:PointerEvent) => {\n          if (! StickerIsSelected(my._pointedSticker as SNS_Sticker)) {\n            if (Event.shiftKey || Event.metaKey) {  // additive/subtractive sel.\n              selectStickers([my._pointedSticker as SNS_Sticker],my._selectedStickers)\n            } else {\n              selectStickers([my._pointedSticker as SNS_Sticker])\n            }\n          }\n\n          my._shapedStickers    = my._selectedStickers\n          my._initialGeometries = my._selectedStickers.map(\n            (Sticker:SNS_Sticker) => Sticker.Geometry\n          )\n          changeGeometriesBy(my._shapedStickers,'c', dx,dy)\n        },\n        onDragContinued:(x:number,y:number, dx:number,dy:number) => {\n          if (my._shapedStickers == null) { return }\n          changeGeometriesBy(my._shapedStickers,'c', dx,dy)\n        },\n        onDragFinished: (x:number,y:number, dx:number,dy:number) => {\n          if (my._shapedStickers == null) { return }\n\n          changeGeometriesBy(my._shapedStickers,'c', dx,dy)\n          finishDraggingAndShaping()\n        },\n        onDragCancelled:(x:number,y:number, dx:number,dy:number) => {\n          abortDraggingAndShaping()\n        },\n        onClicked:onStickerClick\n      })\n\n    /**** handleStickerEvent ****/\n\n      const handleStickerEvent = (Event:PointerEvent, Sticker:SNS_Sticker) => {\n        my._ShapeMode      = 'c'\n        my._pointedSticker = Sticker\n        StickerRecognizer(Event)\n      }\n\n    /**** ShapeHandle Recognizer ****/\n\n      const ShapeHandleRecognizer = DragRecognizerFor(my._ShapeHandleRecognizerSlot, {\n        onlyFrom:     '.SNS.ShapeHandle',\n        Threshold:    0,\n        onDragStarted:(x:number,y:number, dx:number,dy:number) => {\n          my._shapedStickers    = my._selectedStickers\n          my._initialGeometries = my._selectedStickers.map(\n            (Sticker:SNS_Sticker) => Sticker.Geometry\n          )\n          changeGeometriesBy(my._shapedStickers, my._ShapeMode as string, dx,dy)\n        },\n        onDragContinued:(x:number,y:number, dx:number,dy:number) => {\n          if (my._shapedStickers == null) { return }\n          changeGeometriesBy(my._shapedStickers, my._ShapeMode as string, dx,dy)\n        },\n        onDragFinished: (x:number,y:number, dx:number,dy:number) => {\n          if (my._shapedStickers == null) { return }\n\n          changeGeometriesBy(my._shapedStickers, my._ShapeMode as string, dx,dy)\n          finishDraggingAndShaping()\n        },\n        onDragCancelled:(x:number,y:number, dx:number,dy:number) => {\n          abortDraggingAndShaping()\n        }\n      })\n\n      const handleShapeEvent = (Event:PointerEvent, Mode:string) => {\n        my._ShapeMode = Mode\n        ShapeHandleRecognizer(Event)\n      }\n\n    /**** builtinSelectionFor ****/\n\n      function builtinSelectionFor (Sticker:SNS_Sticker):Function {\n        return function (Event:PointerEvent):void {\n          if (Event.button === 0) { selectStickers([Sticker]) }\n        }\n      }\n\n    /**** builtinDraggingFor ****/\n\n      const DragRecognizer:WeakMap<SNS_Sticker,Function> = new WeakMap()\n      const initialGeometry:WeakMap<SNS_Sticker,SNS_Geometry> = new WeakMap()\n\n      function builtinDraggingFor (Sticker:SNS_Sticker):Function {\n        let Recognizer = DragRecognizer.get(Sticker)\n        if (Recognizer == null) {\n          DragRecognizer.set(Sticker, Recognizer = DragRecognizerFor(Sticker, {\n            onlyFrom:     '.builtinDraggable',\n            neverFrom:    '.notBuiltinDraggable',\n            Threshold:    4,\n            onDragStarted:(x:number,y:number, dx:number,dy:number, Event:PointerEvent) => {\n              initialGeometry.set(Sticker,Sticker.Geometry)\n              changeGeometriesBy([Sticker],'c', dx,dy, [initialGeometry.get(Sticker) as SNS_Geometry])\n            },\n            onDragContinued:(x:number,y:number, dx:number,dy:number) => {\n              if (! initialGeometry.has(Sticker)) { return }\n              changeGeometriesBy([Sticker],'c', dx,dy, [initialGeometry.get(Sticker) as SNS_Geometry])\n            },\n            onDragFinished: (x:number,y:number, dx:number,dy:number) => {\n              if (! initialGeometry.has(Sticker)) { return }\n              changeGeometriesBy([Sticker],'c', dx,dy, [initialGeometry.get(Sticker) as SNS_Geometry])\n              initialGeometry.delete(Sticker)\n            },\n            onDragCancelled:(x:number,y:number, dx:number,dy:number) => {\n              if (initialGeometry.has(Sticker)) {\n                changeGeometriesTo([Sticker],[initialGeometry.get(Sticker) as SNS_Geometry])\n              }\n              initialGeometry.delete(Sticker)\n            }\n          }))\n        }\n        return Recognizer as Function\n      }\n\n    /**** horizontal Guides ****/\n\n      function horizontalGuides ():any {\n        if (my._shapedStickers == null) { return '' }\n\n        const EdgeSet:Indexable   = {}\n        const CenterSet:Indexable = {}\n        my._StickerList.filter(\n          (Sticker:SNS_Sticker) => ! StickerIsSelected(Sticker)\n        ).forEach((Sticker:SNS_Sticker) => {\n          const { y,Height } = Sticker.Geometry\n            const yt = Math.round(y)\n            const ym = Math.round(y+Height/2)\n            const yb = Math.round(y+Height)\n          EdgeSet[yt] = EdgeSet[yb] = true\n          CenterSet[ym] = true\n        })\n\n        const horizontalSet:Indexable = {}\n        my._shapedStickers.forEach((Sticker:SNS_Sticker) => {\n          const { y,Height } = Sticker.Geometry\n            const yt = Math.round(y)\n            const ym = Math.round(y+Height/2)\n            const yb = Math.round(y+Height)\n          if (EdgeSet[yt])                                     { horizontalSet[yt] = 'Edge' }\n          if (EdgeSet[ym]   && (horizontalSet[ym] !== 'Edge')) { horizontalSet[ym] = 'Center' }\n          if (EdgeSet[yb])                                     { horizontalSet[yb] = 'Edge' }\n          if (CenterSet[yt] && (horizontalSet[yt] !== 'Edge')) { horizontalSet[yt] = 'Center' }\n          if (CenterSet[ym] && (horizontalSet[ym] !== 'Edge')) { horizontalSet[ym] = 'Center' }\n          if (CenterSet[yb] && (horizontalSet[yb] !== 'Edge')) { horizontalSet[yb] = 'Center' }\n        })\n\n        const horizontalList:string[] = []\n          for (let y in horizontalSet) {\n            if (horizontalSet[y] != null) { horizontalList.push(y) }\n          }\n\n        return html`${horizontalList.map((y:string) => html`\n          <div class=\"SNS horizontalGuide ${horizontalSet[y]}\" style=\"top:${y}px\"/>\n        `)}`\n      }\n\n    /**** vertical Guides ****/\n\n      function verticalGuides ():any {\n        if (my._shapedStickers == null) { return '' }\n\n        const EdgeSet:Indexable   = {}\n        const CenterSet:Indexable = {}\n        my._StickerList.filter(\n          (Sticker:SNS_Sticker) => ! StickerIsSelected(Sticker)\n        ).forEach((Sticker:SNS_Sticker) => {\n          const { x,Width } = Sticker.Geometry\n            const xl = Math.round(x)\n            const xm = Math.round(x+Width/2)\n            const xr = Math.round(x+Width)\n          EdgeSet[xl] = EdgeSet[xr] = true\n          CenterSet[xm] = true\n        })\n\n        const verticalSet:Indexable = {}\n        my._shapedStickers.forEach((Sticker:SNS_Sticker) => {\n          const { x,Width } = Sticker.Geometry\n            const xl = Math.round(x)\n            const xm = Math.round(x+Width/2)\n            const xr = Math.round(x+Width)\n          if (EdgeSet[xl])                                   { verticalSet[xl] = 'Edge' }\n          if (EdgeSet[xm]   && (verticalSet[xm] !== 'Edge')) { verticalSet[xm] = 'Center' }\n          if (EdgeSet[xr])                                   { verticalSet[xr] = 'Edge' }\n          if (CenterSet[xl] && (verticalSet[xl] !== 'Edge')) { verticalSet[xl] = 'Center' }\n          if (CenterSet[xm] && (verticalSet[xm] !== 'Edge')) { verticalSet[xm] = 'Center' }\n          if (CenterSet[xr] && (verticalSet[xr] !== 'Edge')) { verticalSet[xr] = 'Center' }\n        })\n\n        const verticalList:string[] = []\n          for (let x in verticalSet) {\n            if (verticalSet[x] != null) { verticalList.push(x) }\n          }\n        return html`${verticalList.map((x:string) => html`\n          <div class=\"SNS verticalGuide ${verticalSet[x]}\" style=\"left:${x}px\"/>\n        `)}`\n      }\n\n    /**** actual rendering ****/\n\n      const BoardStyle = (Board == null ? undefined : CSSStyleOfVisual(Board))\n\n      return html`<div class=\"SNS BoardView ${Classes}\" style=${BoardStyle}\n        onPointerDown=${LassoRecognizer} onPointerMove=${LassoRecognizer}\n        onPointerUp=${LassoRecognizer} onPointerCancel=${LassoRecognizer}\n      >\n        ${Board == null\n          ? html`<div class=\"SNS Placeholder\"><div>(no Board to show)</div></div>`\n          : StickerList == null\n            ? html`<div class=\"SNS Placeholder\"><div>(no Stickers to show)</div></div>`\n            : StickerList.map((Sticker:SNS_Sticker) => {\n                if (! Sticker.isVisible) { return '' }\n\n                const Geometry = Sticker.Geometry\n                const selected = StickerIsSelected(Sticker)\n\n                return html`<${SNS_StickerView} Sticker=${Sticker} key=${Sticker.Id}\n                  selected=${selected && (Mode === 'run')}\n                  SelectionFrameStyle=${SelectionFrameStyle}\n                  Geometry=${Geometry}\n                  builtinDragging=${builtinDraggingFor(Sticker)}\n                  builtinSelection=${builtinSelectionFor(Sticker)}\n                />`\n              })\n        }\n\n        ${(StickerList != null) && (Mode === 'edit')\n          ? StickerList.map((Sticker:SNS_Sticker) => {\n              if (! Sticker.isVisible) { return '' }\n\n              if (Sticker.isLocked) {\n                return html`\n                  <${SNS_Cover} Sticker=${Sticker} key=${Sticker.Id+'c'}\n                    onPointerDown=${LassoRecognizer} onPointerMove=${LassoRecognizer}\n                    onPointerUp=${LassoRecognizer} onPointerCancel=${LassoRecognizer}\n                  />\n                `\n              } else {\n                const selected = StickerIsSelected(Sticker)\n\n                return html`\n                  <${SNS_Cover} Sticker=${Sticker} key=${Sticker.Id+'c'}\n                    selected=${selected}\n                    onPointerEvent=${(Event:PointerEvent) => handleStickerEvent(Event,Sticker)}\n                  />\n                `\n              }\n            })\n          : ''\n        }\n\n        ${(selectedStickers.length > 0)\n          ? selectedStickers.filter(\n              (Sticker:SNS_Sticker) => Sticker.isVisible && ! Sticker.isLocked\n            ).map((Sticker:SNS_Sticker) => {\n              const Id       = Sticker.Id\n              const Geometry = Sticker.Geometry\n              return html`\n                <${SNS_ShapeHandle} key=${Id+'nw'} Mode=\"nw\" Geometry=${Geometry}\n                  onPointerEvent=${(Event:PointerEvent) => handleShapeEvent(Event,'nw')}/>\n                <${SNS_ShapeHandle} key=${Id+'n'}  Mode=\"n\"  Geometry=${Geometry}\n                  onPointerEvent=${(Event:PointerEvent) => handleShapeEvent(Event,'n')}/>\n                <${SNS_ShapeHandle} key=${Id+'ne'} Mode=\"ne\" Geometry=${Geometry}\n                  onPointerEvent=${(Event:PointerEvent) => handleShapeEvent(Event,'ne')}/>\n                <${SNS_ShapeHandle} key=${Id+'e'}  Mode=\"e\"  Geometry=${Geometry}\n                  onPointerEvent=${(Event:PointerEvent) => handleShapeEvent(Event,'e')}/>\n                <${SNS_ShapeHandle} key=${Id+'se'} Mode=\"se\" Geometry=${Geometry}\n                  onPointerEvent=${(Event:PointerEvent) => handleShapeEvent(Event,'se')}/>\n                <${SNS_ShapeHandle} key=${Id+'s'}  Mode=\"s\"  Geometry=${Geometry}\n                  onPointerEvent=${(Event:PointerEvent) => handleShapeEvent(Event,'s')}/>\n                <${SNS_ShapeHandle} key=${Id+'sw'} Mode=\"sw\" Geometry=${Geometry}\n                  onPointerEvent=${(Event:PointerEvent) => handleShapeEvent(Event,'sw')}/>\n                <${SNS_ShapeHandle} key=${Id+'w'}  Mode=\"w\"  Geometry=${Geometry}\n                  onPointerEvent=${(Event:PointerEvent) => handleShapeEvent(Event,'w')}/>\n              `\n            })\n          : ''\n        }\n        ${this._LassoStart == null\n          ? ''\n          : html`<div class=\"SNS Lasso\" style=${CSSGeometryOfLasso()}></>`\n        }\n        ${horizontalGuides()}\n        ${verticalGuides()}\n      </div>`\n    }\n  }\n\n//------------------------------------------------------------------------------\n//--                             SNS_StickerView                              --\n//------------------------------------------------------------------------------\n\n  class SNS_StickerView extends Component {\n    private _Sticker:SNS_Sticker|undefined\n\n  /**** componentDidMount ****/\n\n    public componentDidMount ():void {\n      const Sticker = this._Sticker as SNS_Sticker\n\n      Sticker['_View'] = (this as Component).base\n      if (Sticker['_onMount'] != null) {\n        Sticker['_onMount']()\n      }\n    }\n\n  /**** componentWillUnmount ****/\n\n    public componentWillUnmount ():void {\n      const Sticker = this._Sticker as SNS_Sticker\n\n      Sticker['_View'] = undefined\n      if (Sticker['_onUnmount'] != null) {\n        Sticker['_onUnmount']()\n      }\n    }\n\n  /**** render ****/\n\n    public render (PropSet:Indexable):any {\n      let {\n        Sticker, selected, SelectionFrameStyle,\n        Geometry, builtinSelection, builtinDragging\n      } = PropSet\n\n      this._Sticker = Sticker\n\n      let { x,y, Width,Height } = Geometry\n        allowInteger('sticker x position',x)\n        allowInteger('sticker y position',y)\n        allowOrdinal     ('sticker width',Width)\n        allowOrdinal    ('sticker height',Height)\n      const CSSGeometry = (\n        (x != null) && (Width != null) && (y != null) && (Height != null)\n        ? `left:${x}px; top:${y}px; width:${Width}px; height:${Height}px; right:auto; bottom:auto;`\n        : ''\n      )\n\n      return html`<div class=\"SNS Sticker ${selected ? 'selected' : ''}\" style=\"\n        ${CSSGeometry};\n        ${selected && (SelectionFrameStyle != null) ? `outline:${SelectionFrameStyle};` : ''}\n        ${CSSStyleOfVisual(Sticker) || ''}\n      \">\n        ${Sticker.Rendering({ builtinSelection,builtinDragging })}\n      </div>`\n    }\n  }//------------------------------------------------------------------------------\n//--                                SNS_Cover                                 --\n//------------------------------------------------------------------------------\n\n  class SNS_Cover extends Component {\n    public render (PropSet:Indexable):any {\n      let { Sticker, onPointerEvent, ...otherProps } = PropSet\n\n      let { x,y, Width,Height } = Sticker.Geometry\n\n      const CSSGeometry = (\n        (x != null) && (Width != null) && (y != null) && (Height != null)\n        ? `left:${x}px; top:${y}px; width:${Width}px; height:${Height}px; right:auto; bottom:auto;`\n        : ''\n      )\n\n      return html`<div class=\"SNS Cover\" style=\"${CSSGeometry}\" ...${otherProps}\n        onPointerDown=${onPointerEvent} onPointerMove=${onPointerEvent}\n        onPointerUp=${onPointerEvent} onPointerCancel=${onPointerEvent}\n      />`\n    }\n  }\n\n//------------------------------------------------------------------------------\n//--                             SNS_ShapeHandle                              --\n//------------------------------------------------------------------------------\n\n  class SNS_ShapeHandle extends Component {\n    public render (PropSet:Indexable):any {\n      let { Mode, Geometry, onPointerEvent, ...otherProps } = PropSet\n\n      let { x,y, Width,Height } = Geometry\n      const xl = x-8, xm = Math.round(x+Width/2)-4,  xr = x+Width\n      const yt = y-8, ym = Math.round(y+Height/2)-4, yb = y+Height\n\n      let CSSGeometry, Cursor\n      switch (Mode) {\n        case 'nw': CSSGeometry = `left:${xl}px; top:${yt}px;`; Cursor = 'nwse'; break\n        case 'n':  CSSGeometry = `left:${xm}px; top:${yt}px;`; Cursor = 'ns';   break\n        case 'ne': CSSGeometry = `left:${xr}px; top:${yt}px;`; Cursor = 'nesw'; break\n        case 'e':  CSSGeometry = `left:${xr}px; top:${ym}px;`; Cursor = 'ew';   break\n        case 'se': CSSGeometry = `left:${xr}px; top:${yb}px;`; Cursor = 'nwse'; break\n        case 's':  CSSGeometry = `left:${xm}px; top:${yb}px;`; Cursor = 'ns';   break\n        case 'sw': CSSGeometry = `left:${xl}px; top:${yb}px;`; Cursor = 'nesw'; break\n        case 'w':  CSSGeometry = `left:${xl}px; top:${ym}px;`; Cursor = 'ew';   break\n      }\n      Cursor = 'cursor:' + Cursor + '-resize'\n\n      return html`<div class=\"SNS ShapeHandle\" style=\"${CSSGeometry} ${Cursor}\" ...${otherProps}\n        onPointerDown=${onPointerEvent} onPointerMove=${onPointerEvent}\n        onPointerUp=${onPointerEvent} onPointerCancel=${onPointerEvent}\n      />`\n    }\n  }\n\n// @ts-ignore TS2339 allow global variable \"SNS_BoardView\"\n  window.SNS_BoardView = SNS_BoardView\n\n  document.dispatchEvent(\n// @ts-ignore TS2339 allow global variable \"SNS_BoardView\"\n    new CustomEvent('SNS_BoardView',{ detail:window.SNS_BoardView })\n  )\n"],"names":["m","e","r","fromDocumentTo","Conversion","Stylesheet","SNS_BoardView","Component","__publicField","Board","PropSet","my","Classes","StickerList","Placeholder","Mode","SelectionLimit","selectedStickers","onSelectionChange","onStickerSelected","onStickerDeselected","SelectionFrameStyle","SelectionHandleStyle","LassoMode","onGeometryChange","SnapToGrid","GridWidth","GridHeight","finishDraggingAndShaping","abortDraggingAndShaping","changeGeometriesTo","allowTextline","allowBoard","allowListSatisfying","ValueIsSticker","allowOneOf","allowOrdinal","allowFunction","allowText","allowBoolean","allowCardinal","selectedStickerSet","selectedSticker","selectStickers","SelectionA","SelectionB","newSelection","Sticker","StickersToSelect","StickersToDeselect","deselectedSticker","StickerIsSelected","GeometryOfLasso","x0","y0","x1","y1","LassoX","LassoWidth","LassoY","LassoHeight","CSSGeometryOfLasso","x","y","Width","Height","StickersCaughtByLasso","LassoX0","LassoY0","LassoX1","LassoY1","dragLassoTo","applyLasso","abortLasso","onBoardClick","LassoRecognizer","DragClickRecognizerFor","dx","dy","GeometryList","changeGeometriesBy","initialGeometries","dX","dY","dW","dH","Geometry","xl","xr","yt","yb","xl_","xr_","yt_","yb_","onStickerClick","Event","SelectionChanged","StickerRecognizer","handleStickerEvent","ShapeHandleRecognizer","DragRecognizerFor","handleShapeEvent","builtinSelectionFor","DragRecognizer","initialGeometry","builtinDraggingFor","Recognizer","horizontalGuides","EdgeSet","CenterSet","ym","horizontalSet","horizontalList","html","verticalGuides","xm","verticalSet","verticalList","BoardStyle","CSSStyleOfVisual","selected","SNS_StickerView","SNS_Cover","Id","SNS_ShapeHandle","builtinSelection","builtinDragging","allowInteger","CSSGeometry","onPointerEvent","otherProps","Cursor"],"mappings":"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","x_google_ignoreList":[0]}