{"version":3,"file":"sns-boardview.modern.js","sources":["../src/sns-boardview.ts"],"sourcesContent":["/*******************************************************************************\n*                                                                              *\n*                BoardView for \"Shareable Note Stickers\" (SNS)                 *\n*                                                                              *\n*******************************************************************************/\n\n  import {\n    allowBoolean,\n    allowInteger, allowOrdinal, allowCardinal,\n    allowText, allowTextline,\n    allowFunction,\n    allowListSatisfying,\n    allowOneOf,\n  } from 'javascript-interface-library'\n\n  import {\n    SNS_Board, SNS_Sticker,\n    ValueIsSticker,\n    allowBoard,\n    CSSStyleOfVisual,\n  } from 'shareable-note-stickers'\n\n  import Conversion from 'svelte-coordinate-conversion'\n  const { fromDocumentTo } = Conversion\n\n  import { html, Component } from 'htm/preact'\n\n// @ts-ignore TS7016 *C* sometimes, I hate package management\n  import { DragRecognizerFor, DragClickRecognizerFor } from 'protoux'\n\n/**** install stylesheet for this BoardView ****/\n\n  const Stylesheet = document.createElement('style')\n    Stylesheet.setAttribute('id','SNS Stylesheet')\n    Stylesheet.innerHTML = `/*******************************************************************************\n*                                                                              *\n*                        Shareable Note Stickers (SNS)                         *\n*                                                                              *\n*******************************************************************************/\n\n/**** all SNS elements are absolutely positioned ****/\n\n  .SNS {\n    display:block; position:absolute;\n    margin:0px; padding:0px;\n    background:none; border:none; border-radius:0px; outline:none;\n  }\n\n/**** \"brokenSticker\" and Error Indicator ****/\n\n  .SNS.brokenSticker {\n    overflow:hidden;\n    border:dotted 1px orange; background:rgba(255,0,0,0.1);\n  }\n\n  .SNS.ErrorIndicator {\n    overflow:hidden;\n    left:0px; top:0px; width:24px; height:24px;\n    background:url(\"data:image/svg+xml,%3C%3Fxml version='1.0' encoding='utf-8'%3F%3E%3Csvg width='24px' height='24px' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M12 17.0001H12.01M12 10.0001V14.0001M6.41209 21.0001H17.588C19.3696 21.0001 20.2604 21.0001 20.783 20.6254C21.2389 20.2985 21.5365 19.7951 21.6033 19.238C21.6798 18.5996 21.2505 17.819 20.3918 16.2579L14.8039 6.09805C13.8897 4.4359 13.4326 3.60482 12.8286 3.32987C12.3022 3.09024 11.6978 3.09024 11.1714 3.32987C10.5674 3.60482 10.1103 4.4359 9.19614 6.09805L3.6082 16.2579C2.74959 17.819 2.32028 18.5996 2.39677 19.238C2.46351 19.7951 2.76116 20.2985 3.21709 20.6254C3.7396 21.0001 4.63043 21.0001 6.41209 21.0001Z' stroke='orange' stroke-width='2' stroke-linecap='round' stroke-linejoin='round' fill='white'/%3E%3C/svg%3E\");\n    pointer-events:auto;\n  }\n\n\n/**** BoardView ****/\n\n  .SNS.BoardView {\n    left:0px; top:0px; right:0px; bottom:0px;\n  }\n\n/**** Sticker and Contents, Cover ****/\n\n  .SNS.Sticker {}\n  .SNS.Sticker > .SNS {\n    -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none;\n    user-select:none;\n\n    display:block; position:absolute;\n    left:0px; top:0px; width:100%; height:100%; right:auto; bottom:auto;\n  }\n\n  .SNS.Cover {\n    -webkit-user-select:none; -moz-user-select:none; -ms-user-select:none;\n    user-select:none;\n\n    z-index:1000000;\n  }\n\n/**** Selection Markers ****/\n\n  .SNS.Sticker.selected, .SNS.Cover[selected] {\n    outline:dotted 2px orangered;\n  }\n\n  .SNS.ShapeHandle {\n    width:8px; height:8px;\n    background:orangered; border:solid 1px darkgray;\n    z-index:1000001; /* above .SNS.Cover */\n  }\n\n/**** Selection Lasso ****/\n\n  .SNS.Lasso {\n    background:rgba(255,69,0, 0.1); /* border:dashed 2px orangered; */\n  }\n\n/**** Dragging Guides ****/\n\n  .SNS.horizontalGuide.Edge {\n    left:0px; right:0px; height:1px;\n    border-top:dashed 1px orangered;\n  }\n  .SNS.verticalGuide.Edge {\n    top:0px; bottom:0px; width:1px;\n    border-left:dashed 1px orangered;\n  }\n\n  .SNS.horizontalGuide.Center {\n    left:0px; right:0px; height:1px;\n    border-top:dotted 1px orangered;\n  }\n  .SNS.verticalGuide.Center {\n    top:0px; bottom:0px; width:1px;\n    border-left:dotted 1px orangered;\n  }\n\n/**** Placeholder ****/\n\n  .SNS.Placeholder {\n    display:block; position:relative;\n    width:100%; height:100%;\n  }\n\n  .SNS.Placeholder > * {\n    display:block; position:absolute;\n    left:50%; top:50%;\n    transform:translate(-55%,-50%);\n    white-space:nowrap;\n  }\n\n`\n  document.head.appendChild(Stylesheet)\n\n/**** make some existing types indexable ****/\n\n  interface Indexable { [Key:string]:any }\n\n//------------------------------------------------------------------------------\n//--                             Type Definitions                             --\n//------------------------------------------------------------------------------\n\n/**** geometry-related types ****/\n\n  export type SNS_Location  = number         // mainly for illustrative purposes\n  export type SNS_Dimension = number                                     // dto.\n  export type SNS_Position  = { x:SNS_Location,y:SNS_Location }\n  export type SNS_Size      = { Width:SNS_Dimension,Height:SNS_Dimension }\n  export type SNS_Geometry  = { x:SNS_Location,y:SNS_Location, Width:SNS_Dimension,Height:SNS_Dimension }\n\n//------------------------------------------------------------------------------\n//--                              SNS_BoardView                               --\n//------------------------------------------------------------------------------\n\n  export class SNS_BoardView extends Component {\n    private _Board:SNS_Board|undefined\n\n    private _StickerList:SNS_Sticker[] = []\n    private _pointedSticker:SNS_Sticker|undefined\n    private _selectedStickers:SNS_Sticker[] = []       // for dragging & shaping\n    private _SelectionLimit:number = Infinity\n\n    private _LassoStart:SNS_Position|undefined\n    private _LassoEnd:SNS_Position|undefined\n    private _SelectionBeforeLasso:SNS_Sticker[] = []\n\n    private _ShapeMode:string|undefined\n    private _shapedStickers:SNS_Sticker[]|undefined\n    private _initialGeometries:SNS_Geometry[]|undefined\n\n    private _SnapToGrid:boolean = false\n    private _GridWidth:number   = 1\n    private _GridHeight:number  = 1\n\n    private _StickerRecognizerSlot = {}\n    private _ShapeHandleRecognizerSlot = {}\n    private _LassoRecognizerSlot = {}\n\n    public state:Indexable = { Value:0 }\n\n  /**** _mountBoard ****/\n\n    private _mountBoard (Board:SNS_Board|undefined):void {\n      if ((Board != null) && ((this as Component).base != null)) {\n        Board['_View'] = (this as Component).base\n        if (Board['_onMount'] != null) {\n          Board['_onMount']()\n        }\n      }\n      this._Board = Board\n    }\n\n  /**** _unmountBoard ****/\n\n    private _unmountBoard ():void {\n      const Board = this._Board\n      if (Board != null) {\n        Board['_View'] = undefined\n        if (Board['_onUnmount'] != null) {\n          Board['_onUnmount']()\n        }\n      }\n    }\n\n  /**** componentDidMount/WillUnmount ****/\n\n    public componentDidMount    ():void { this._mountBoard(this._Board) }\n    public componentWillUnmount ():void { this._unmountBoard() }\n\n  /**** rerender ****/\n\n    public rerender ():void {\n// @ts-ignore TS2339 \"Value\" is a valid property\n      (this as Component).setState({ Value:(this as Component).state.Value + 1 })\n    }\n\n  /**** render ****/\n\n    public render (PropSet:Indexable):any {\n      const my = this\n\n      let {\n        Classes, Board, StickerList, Placeholder, Mode,\n        SelectionLimit, selectedStickers,\n        onSelectionChange, onStickerSelected, onStickerDeselected,\n        SelectionFrameStyle, SelectionHandleStyle,\n        LassoMode, onGeometryChange,\n        SnapToGrid, GridWidth, GridHeight,\n      } = PropSet\n\n      if (this._Board !== Board) {\n        this._unmountBoard()\n        this._mountBoard(Board)\n      }\n\n    /**** finishDraggingAndShaping ****/\n\n      function finishDraggingAndShaping ():void {\n        my._pointedSticker    = undefined\n        my._shapedStickers    = undefined\n        my._initialGeometries = undefined\n      }\n\n    /**** abortDraggingAndShaping ****/\n\n      function abortDraggingAndShaping ():void {\n        if (my._shapedStickers != null) {\n          changeGeometriesTo(my._shapedStickers,my._initialGeometries as SNS_Geometry[])\n        }\n        finishDraggingAndShaping()\n      }\n\n    /**** validate given properties ****/\n\n      allowTextline      ('board CSS class names',Classes)\n      allowBoard                         ('board',Board)\n      allowListSatisfying         ('sticker list',StickerList, ValueIsSticker)\n      allowTextline           ('placeholder text',Placeholder)\n      allowOneOf                    ('board mode',Mode, ['edit','run'])\n      allowOrdinal             ('selection limit',SelectionLimit)\n      allowListSatisfying('list of selected stickers',selectedStickers, ValueIsSticker)\n      allowFunction  ('selection change callback',onSelectionChange)\n      allowFunction         ('selection callback',onStickerSelected)\n      allowFunction       ('deselection callback',onStickerDeselected)\n      allowTextline  ('selection frame CSS style',SelectionFrameStyle)\n      allowText     ('selection handle CSS style',SelectionHandleStyle)\n      allowOneOf          ('lasso selection mode',LassoMode, ['touch','contain'])\n      allowFunction   ('geometry change callback',onGeometryChange)\n      allowBoolean           ('\"SnapToGrid\" mode',SnapToGrid)\n      allowCardinal                 ('grid width',GridWidth)\n      allowCardinal                ('grid height',GridHeight)\n\n    /**** provide defaults for missing properties ****/\n\n      if (Classes              == null) { Classes               = '' }\n      if (Placeholder          == null) { Placeholder           = '(empty)' }\n      if (Mode                 == null) { Mode                  = 'run' }\n      if (SelectionLimit       == null) { SelectionLimit        = Infinity }\n      if (selectedStickers     == null) { selectedStickers      = [] }\n//    if (SelectionFrameStyle  == null) { SelectionFrameStyle   = 'dotted 2px orangered' }\n      if (SelectionHandleStyle == null) { SelectionHandleStyle  = 'background:orangered; border:solid 1px darkgray' }\n      if (LassoMode            == null) { LassoMode             = 'contain' }\n      if (SnapToGrid           == null) { SnapToGrid            = false }\n      if (GridWidth            == null) { GridWidth             = 10 }\n      if (GridHeight           == null) { GridHeight            = 10 }\n\n    /**** sanitize Selections ****/\n\n      const selectedStickerSet:Set<SNS_Sticker> = new Set()\n        selectedStickers = selectedStickers.filter((selectedSticker:SNS_Sticker) => {\n          if (\n            ValueIsSticker(selectedSticker) &&\n            ! selectedStickerSet.has(selectedSticker)\n          ) {\n            selectedStickerSet.add(selectedSticker)\n            return true\n          } else {\n            abortDraggingAndShaping()\n            return false        // invalid selections don't invoke any callbacks\n          }\n        })\n      if (selectedStickers.length > SelectionLimit) {\n        selectStickers(selectedStickers.slice(0,SelectionLimit))\n      }\n\n      my._StickerList      = StickerList\n      my._selectedStickers = selectedStickers   // needed for dragging & shaping\n      my._SelectionLimit   = SelectionLimit                              // dto.\n\n      my._SnapToGrid = SnapToGrid                                        // dto.\n      my._GridWidth  = GridWidth                                         // dto.\n      my._GridHeight = GridHeight                                        // dto.\n\n    /**** Sticker Selection ****/\n\n      function selectStickers (\n        SelectionA:SNS_Sticker[], SelectionB:SNS_Sticker[] = []\n      ):void {\n        const newSelection:SNS_Sticker[] = SelectionA.slice()\n        SelectionB.forEach((Sticker:SNS_Sticker) => {\n          if (newSelection.indexOf(Sticker) < 0) { newSelection.push(Sticker) }\n        })\n\n        if (selectedStickers.length > my._SelectionLimit) {\n          newSelection.length = my._SelectionLimit\n        }\n\n        const StickersToSelect:SNS_Sticker[]   = []\n        const StickersToDeselect:SNS_Sticker[] = []\n          newSelection.forEach((Sticker:SNS_Sticker) => {\n            if (my._selectedStickers.indexOf(Sticker) < 0) {\n              StickersToSelect.push(Sticker)\n            }\n          })\n\n          my._selectedStickers.forEach((Sticker:SNS_Sticker) => {\n            if (newSelection.indexOf(Sticker) < 0) {\n              StickersToDeselect.push(Sticker)\n            }\n          })\n        selectedStickers = my._selectedStickers = newSelection\n\n        if ((StickersToSelect.length > 0) || (StickersToDeselect.length > 0)) {\n          abortDraggingAndShaping()\n\n          if (onSelectionChange != null) {\n            onSelectionChange(selectedStickers)\n          }\n        }\n\n        if ((StickersToDeselect.length > 0) && (onStickerDeselected != null)) {\n          StickersToDeselect.forEach((deselectedSticker:SNS_Sticker) => {\n            onStickerDeselected(deselectedSticker)\n          })\n        }\n\n        if ((StickersToSelect.length > 0) && (onStickerSelected != null)) {\n          StickersToSelect.forEach((selectedSticker:SNS_Sticker) => {\n            onStickerSelected(selectedSticker)\n          })\n        }\n      }\n\n      function StickerIsSelected (Sticker:SNS_Sticker):boolean {\n        return (selectedStickers.indexOf(Sticker) >= 0)\n      }\n\n    /**** Lasso Selection ****/\n\n      function GeometryOfLasso ():SNS_Geometry {\n        const { x:x0,y:y0 } = my._LassoStart as SNS_Position\n        const { x:x1,y:y1 } = my._LassoEnd || my._LassoStart as SNS_Position\n\n        let LassoX = (x0 <= x1 ? x0 : x1); let LassoWidth  = (x0 <= x1 ? x1-x0 : x0-x1)\n        let LassoY = (y0 <= y1 ? y0 : y1); let LassoHeight = (y0 <= y1 ? y1-y0 : y0-y1)\n\n        return { x:LassoX,y:LassoY, Width:LassoWidth,Height:LassoHeight }\n      }\n\n      function CSSGeometryOfLasso ():string {\n        const { x,y, Width,Height } = GeometryOfLasso()\n        return `left:${x}px; top:${y}px; width:${Width}px; height:${Height}px`\n      }\n\n      function StickersCaughtByLasso ():SNS_Sticker[] {\n        let { x:LassoX0,y:LassoY0, Width:LassoWidth,Height:LassoHeight } = GeometryOfLasso()\n        let LassoX1 = LassoX0+LassoWidth\n        let LassoY1 = LassoY0+LassoHeight\n\n        if (LassoMode === 'touch') {\n          return my._StickerList.filter((Sticker:SNS_Sticker) => {\n            if (! Sticker.isVisible || Sticker.isLocked) { return false }\n// @ts-ignore TS2339 strange: why does TS not recognize \"isSelectable\"?\n            if ((Mode === 'run') && ! Sticker.isSelectable) { return false }\n\n            const { x,y, Width,Height } = Sticker.Geometry\n            return (\n              (LassoX0 <= x+Width)  && (x <= LassoX1) &&\n              (LassoY0 <= y+Height) && (y <= LassoY1)\n            )\n          })\n        } else { // 'enclose'\n          return my._StickerList.filter((Sticker:SNS_Sticker) => {\n            if (! Sticker.isVisible || Sticker.isLocked) { return false }\n// @ts-ignore TS2339 strange: why does TS not recognize \"isSelectable\"?\n            if ((Mode === 'run') && ! Sticker.isSelectable) { return false }\n\n            const { x,y, Width,Height } = Sticker.Geometry\n            return (\n              (LassoX0 <= x) && (x+Width  <= LassoX1) &&\n              (LassoY0 <= y) && (y+Height <= LassoY1)\n            )\n          })\n        }\n      }\n\n      function dragLassoTo (x:SNS_Location,y:SNS_Location):void {\n        my._LassoEnd = { x,y }\n        selectStickers(my._SelectionBeforeLasso, StickersCaughtByLasso())\n      }\n\n      function applyLasso ():void {\n        my._LassoStart = my._LassoEnd = undefined\n        my._SelectionBeforeLasso = []\n      }\n\n      function abortLasso ():void {\n        my._LassoStart = my._LassoEnd = undefined\n        selectStickers(my._SelectionBeforeLasso)\n        my._SelectionBeforeLasso = []\n      }\n\n    /**** Lasso Recognizer ****/\n\n      function onBoardClick ():void {\n        selectStickers([])\n      }\n\n      const LassoRecognizer = DragClickRecognizerFor(my._LassoRecognizerSlot, {\n        onlyFrom:     '.SNS.BoardView,.SNS.Sticker,.SNS.Sticker *',\n        neverFrom:    '.SNS.Sticker.selectable,.SNS.Sticker.selectable *',\n        Threshold:    4,\n        onDragStarted:(x:number,y:number, dx:number,dy:number) => {\n          my._SelectionBeforeLasso = selectedStickers.slice()\n\n// @ts-ignore TS2345 type casting is ok here\n          ;({ left:x,top:y } = fromDocumentTo('local',{ left:x,top:y },(my as Component).base))\n\n          my._LassoStart = { x,y }\n          dragLassoTo(x,y)\n          my.rerender()\n        },\n        onDragContinued:(x:number,y:number, dx:number,dy:number) => {\n// @ts-ignore TS2532 my._LassoStart is _not_ undefined\n          dragLassoTo(my._LassoStart.x+dx,my._LassoStart.y+dy)\n          my.rerender()\n        },\n        onDragFinished: (x:number,y:number, dx:number,dy:number) => {\n// @ts-ignore TS2532 my._LassoStart is _not_ undefined\n          dragLassoTo(my._LassoStart.x+dx,my._LassoStart.y+dy)\n          applyLasso()\n          my.rerender()\n        },\n        onDragCancelled:(x:number,y:number, dx:number,dy:number) => {\n          abortLasso()\n          my.rerender()\n        },\n        onClicked:onBoardClick\n      })\n\n    /**** Geometry Handling ****/\n\n      function changeGeometriesTo (\n        StickerList:SNS_Sticker[], GeometryList:SNS_Geometry[]\n      ):void {\n        if (onGeometryChange != null) {\n          onGeometryChange(StickerList,GeometryList)\n          my.rerender()\n        }\n      }\n\n      function changeGeometriesBy (\n        StickerList:SNS_Sticker[], Mode:string, dx:number,dy:number,\n        initialGeometries?:SNS_Geometry[]\n      ):void {\n        if (onGeometryChange == null) { return }\n\n        let dX:number = 0, dY:number = 0, dW:number = 0, dH:number = 0\n        switch (Mode) {\n          case 'nw': dX = dx; dW = -dx; dY = dy; dH = -dy; break\n          case 'n':                     dY = dy; dH = -dy; break\n          case 'ne':          dW = dx;  dY = dy; dH = -dy; break\n          case 'e':           dW = dx;                     break\n          case 'se':          dW = dx;           dH = dy;  break\n          case 's':                              dH = dy;  break\n          case 'sw': dX = dx; dW = -dx;          dH = dy;  break\n          case 'w':  dX = dx; dW = -dx;                    break\n          case 'c':  dX = dx;           dY = dy;\n        }\n\n        if (initialGeometries == null) {\n          initialGeometries = my._initialGeometries as SNS_Geometry[]\n        }\n\n        const GeometryList = initialGeometries.map(\n          (Geometry:SNS_Geometry) => {\n            let Width:number  = Math.max(0,Geometry.Width+dW)\n            let Height:number = Math.max(0,Geometry.Height+dH)\n\n            let xl:number = Geometry.x+dX, xr = xl + Width\n            let yt:number = Geometry.y+dY, yb = yt + Height\n\n            if (my._SnapToGrid) {\n              let xl_ = my._GridWidth*Math.round(xl/my._GridWidth)\n              let xr_ = my._GridWidth*Math.round(xr/my._GridWidth)\n              let yt_ = my._GridHeight*Math.round(yt/my._GridHeight)\n              let yb_ = my._GridHeight*Math.round(yb/my._GridHeight)\n\n              switch (Mode) {\n                case 'nw': xl = Math.min(xl_,xr); yt = Math.min(yt_,yb); break\n                case 'n':                         yt = Math.min(yt_,yb); break\n                case 'ne': xr = Math.max(xl,xr_); yt = Math.min(yt_,yb); break\n                case 'e':  xr = Math.max(xl,xr_);                        break\n                case 'se': xr = Math.max(xl,xr_); yb = Math.max(yt,yb_); break\n                case 's':                         yb = Math.max(yt,yb_); break\n                case 'sw': xl = Math.min(xl_,xr); yb = Math.max(yt,yb_); break\n                case 'w':  xl = Math.min(xl_,xr);                        break\n                case 'c':  xl = xl_; xr = xl+Width; yt = yt_; yb = yt+Height\n              }\n            }\n            return { x:xl,y:yt, Width:xr-xl,Height:yb-yt }\n          }\n        )\n\n        changeGeometriesTo(StickerList,GeometryList)\n      }\n\n    /**** Sticker Drag/Select Recognizer ****/\n\n      const onStickerClick = (x:number,y:number, Event:PointerEvent) => {\n        if (SelectionLimit === 0) { return }\n\n        const Sticker = my._pointedSticker as SNS_Sticker\n\n        let SelectionChanged:boolean = false\n        let StickersToSelect:SNS_Sticker[], StickersToDeselect:SNS_Sticker[]\n        if (Event.shiftKey || Event.metaKey) { // additive/subtractive selection\n          SelectionChanged = true\n          if (StickerIsSelected(Sticker)) {\n            StickersToDeselect = [Sticker]\n            selectedStickers   = selectedStickers.filter(\n              (selectedSticker:SNS_Sticker) => (selectedSticker !== Sticker)\n            )\n          } else {\n            if (selectedStickers.length === SelectionLimit) {\n              StickersToDeselect = [selectedStickers.shift()]\n            }\n            StickersToSelect = [Sticker]\n            selectedStickers.push(Sticker)\n          }\n        } else {                                         // definitive selection\n          StickersToDeselect = selectedStickers.filter(\n            (selectedSticker:SNS_Sticker) => (selectedSticker !== Sticker)\n          )\n          SelectionChanged = ! StickerIsSelected(Sticker)\n          StickersToSelect  = (SelectionChanged ? [Sticker] : [])\n          selectedStickers  = [Sticker]\n        }\n\n        if (SelectionChanged && (onSelectionChange != null)) {\n          onSelectionChange(selectedStickers)\n        }\n\n// @ts-ignore TS2454 let's check IF variables were assigned\n        if ((StickersToDeselect != null) && (onStickerDeselected != null)) {\n          StickersToDeselect.forEach((deselectedSticker:SNS_Sticker) => {\n            onStickerDeselected(deselectedSticker)\n          })\n        }\n\n// @ts-ignore TS2454 let's check IF variables were assigned\n        if ((StickersToSelect != null) && (onStickerSelected != null)) {\n          StickersToSelect.forEach((selectedSticker:SNS_Sticker) => {\n            onStickerSelected(selectedSticker)\n          })\n        }\n\n        if (SelectionChanged) { my.rerender() }\n      }\n\n    /**** StickerRecognizer ****/\n\n      const StickerRecognizer = DragClickRecognizerFor(my._StickerRecognizerSlot, {\n        onlyFrom:     '.SNS.Cover',\n        Threshold:    4,\n        onDragStarted:(x:number,y:number, dx:number,dy:number, Event:PointerEvent) => {\n          if (! StickerIsSelected(my._pointedSticker as SNS_Sticker)) {\n            if (Event.shiftKey || Event.metaKey) {  // additive/subtractive sel.\n              selectStickers([my._pointedSticker as SNS_Sticker],my._selectedStickers)\n            } else {\n              selectStickers([my._pointedSticker as SNS_Sticker])\n            }\n          }\n\n          my._shapedStickers    = my._selectedStickers\n          my._initialGeometries = my._selectedStickers.map(\n            (Sticker:SNS_Sticker) => Sticker.Geometry\n          )\n          changeGeometriesBy(my._shapedStickers,'c', dx,dy)\n        },\n        onDragContinued:(x:number,y:number, dx:number,dy:number) => {\n          if (my._shapedStickers == null) { return }\n          changeGeometriesBy(my._shapedStickers,'c', dx,dy)\n        },\n        onDragFinished: (x:number,y:number, dx:number,dy:number) => {\n          if (my._shapedStickers == null) { return }\n\n          changeGeometriesBy(my._shapedStickers,'c', dx,dy)\n          finishDraggingAndShaping()\n        },\n        onDragCancelled:(x:number,y:number, dx:number,dy:number) => {\n          abortDraggingAndShaping()\n        },\n        onClicked:onStickerClick\n      })\n\n    /**** handleStickerEvent ****/\n\n      const handleStickerEvent = (Event:PointerEvent, Sticker:SNS_Sticker) => {\n        my._ShapeMode      = 'c'\n        my._pointedSticker = Sticker\n        StickerRecognizer(Event)\n      }\n\n    /**** ShapeHandle Recognizer ****/\n\n      const ShapeHandleRecognizer = DragRecognizerFor(my._ShapeHandleRecognizerSlot, {\n        onlyFrom:     '.SNS.ShapeHandle',\n        Threshold:    0,\n        onDragStarted:(x:number,y:number, dx:number,dy:number) => {\n          my._shapedStickers    = my._selectedStickers\n          my._initialGeometries = my._selectedStickers.map(\n            (Sticker:SNS_Sticker) => Sticker.Geometry\n          )\n          changeGeometriesBy(my._shapedStickers, my._ShapeMode as string, dx,dy)\n        },\n        onDragContinued:(x:number,y:number, dx:number,dy:number) => {\n          if (my._shapedStickers == null) { return }\n          changeGeometriesBy(my._shapedStickers, my._ShapeMode as string, dx,dy)\n        },\n        onDragFinished: (x:number,y:number, dx:number,dy:number) => {\n          if (my._shapedStickers == null) { return }\n\n          changeGeometriesBy(my._shapedStickers, my._ShapeMode as string, dx,dy)\n          finishDraggingAndShaping()\n        },\n        onDragCancelled:(x:number,y:number, dx:number,dy:number) => {\n          abortDraggingAndShaping()\n        }\n      })\n\n      const handleShapeEvent = (Event:PointerEvent, Mode:string) => {\n        my._ShapeMode = Mode\n        ShapeHandleRecognizer(Event)\n      }\n\n    /**** builtinSelectionFor ****/\n\n      function builtinSelectionFor (Sticker:SNS_Sticker):Function {\n        return function (Event:PointerEvent):void {\n          if (Event.button === 0) { selectStickers([Sticker]) }\n        }\n      }\n\n    /**** builtinDraggingFor ****/\n\n      const DragRecognizer:WeakMap<SNS_Sticker,Function> = new WeakMap()\n      const initialGeometry:WeakMap<SNS_Sticker,SNS_Geometry> = new WeakMap()\n\n      function builtinDraggingFor (Sticker:SNS_Sticker):Function {\n        let Recognizer = DragRecognizer.get(Sticker)\n        if (Recognizer == null) {\n          DragRecognizer.set(Sticker, Recognizer = DragRecognizerFor(Sticker, {\n            onlyFrom:     '.builtinDraggable',\n            neverFrom:    '.notBuiltinDraggable',\n            Threshold:    4,\n            onDragStarted:(x:number,y:number, dx:number,dy:number, Event:PointerEvent) => {\n              my._shapedStickers = [Sticker]\n              initialGeometry.set(Sticker,Sticker.Geometry)\n              changeGeometriesBy([Sticker],'c', dx,dy, [initialGeometry.get(Sticker) as SNS_Geometry])\n            },\n            onDragContinued:(x:number,y:number, dx:number,dy:number) => {\n              if (! initialGeometry.has(Sticker)) { return }\n              changeGeometriesBy([Sticker],'c', dx,dy, [initialGeometry.get(Sticker) as SNS_Geometry])\n            },\n            onDragFinished: (x:number,y:number, dx:number,dy:number) => {\n              if (! initialGeometry.has(Sticker)) { return }\n              changeGeometriesBy([Sticker],'c', dx,dy, [initialGeometry.get(Sticker) as SNS_Geometry])\n              initialGeometry.delete(Sticker)\n              my._shapedStickers = []\n            },\n            onDragCancelled:(x:number,y:number, dx:number,dy:number) => {\n              if (initialGeometry.has(Sticker)) {\n                changeGeometriesTo([Sticker],[initialGeometry.get(Sticker) as SNS_Geometry])\n              }\n              initialGeometry.delete(Sticker)\n              my._shapedStickers = []\n            }\n          }))\n        }\n        return Recognizer as Function\n      }\n\n    /**** horizontal Guides ****/\n\n      function horizontalGuides ():any {\n        if (my._shapedStickers == null) { return '' }\n\n        const EdgeSet:Indexable   = {}\n        const CenterSet:Indexable = {}\n        my._StickerList.filter(\n          (Sticker:SNS_Sticker) => ! StickerIsSelected(Sticker)\n        ).forEach((Sticker:SNS_Sticker) => {\n          const { y,Height } = Sticker.Geometry\n            const yt = Math.round(y)\n            const ym = Math.round(y+Height/2)\n            const yb = Math.round(y+Height)\n          EdgeSet[yt] = EdgeSet[yb] = true\n          CenterSet[ym] = true\n        })\n\n        const horizontalSet:Indexable = {}\n        my._shapedStickers.forEach((Sticker:SNS_Sticker) => {\n          const { y,Height } = Sticker.Geometry\n            const yt = Math.round(y)\n            const ym = Math.round(y+Height/2)\n            const yb = Math.round(y+Height)\n          if (EdgeSet[yt])                                     { horizontalSet[yt] = 'Edge' }\n          if (EdgeSet[ym]   && (horizontalSet[ym] !== 'Edge')) { horizontalSet[ym] = 'Center' }\n          if (EdgeSet[yb])                                     { horizontalSet[yb] = 'Edge' }\n          if (CenterSet[yt] && (horizontalSet[yt] !== 'Edge')) { horizontalSet[yt] = 'Center' }\n          if (CenterSet[ym] && (horizontalSet[ym] !== 'Edge')) { horizontalSet[ym] = 'Center' }\n          if (CenterSet[yb] && (horizontalSet[yb] !== 'Edge')) { horizontalSet[yb] = 'Center' }\n        })\n\n        const horizontalList:string[] = []\n          for (let y in horizontalSet) {\n            if (horizontalSet[y] != null) { horizontalList.push(y) }\n          }\n\n        return html`${horizontalList.map((y:string) => html`\n          <div class=\"SNS horizontalGuide ${horizontalSet[y]}\" style=\"top:${y}px\"/>\n        `)}`\n      }\n\n    /**** vertical Guides ****/\n\n      function verticalGuides ():any {\n        if (my._shapedStickers == null) { return '' }\n\n        const EdgeSet:Indexable   = {}\n        const CenterSet:Indexable = {}\n        my._StickerList.filter(\n          (Sticker:SNS_Sticker) => ! StickerIsSelected(Sticker)\n        ).forEach((Sticker:SNS_Sticker) => {\n          const { x,Width } = Sticker.Geometry\n            const xl = Math.round(x)\n            const xm = Math.round(x+Width/2)\n            const xr = Math.round(x+Width)\n          EdgeSet[xl] = EdgeSet[xr] = true\n          CenterSet[xm] = true\n        })\n\n        const verticalSet:Indexable = {}\n        my._shapedStickers.forEach((Sticker:SNS_Sticker) => {\n          const { x,Width } = Sticker.Geometry\n            const xl = Math.round(x)\n            const xm = Math.round(x+Width/2)\n            const xr = Math.round(x+Width)\n          if (EdgeSet[xl])                                   { verticalSet[xl] = 'Edge' }\n          if (EdgeSet[xm]   && (verticalSet[xm] !== 'Edge')) { verticalSet[xm] = 'Center' }\n          if (EdgeSet[xr])                                   { verticalSet[xr] = 'Edge' }\n          if (CenterSet[xl] && (verticalSet[xl] !== 'Edge')) { verticalSet[xl] = 'Center' }\n          if (CenterSet[xm] && (verticalSet[xm] !== 'Edge')) { verticalSet[xm] = 'Center' }\n          if (CenterSet[xr] && (verticalSet[xr] !== 'Edge')) { verticalSet[xr] = 'Center' }\n        })\n\n        const verticalList:string[] = []\n          for (let x in verticalSet) {\n            if (verticalSet[x] != null) { verticalList.push(x) }\n          }\n        return html`${verticalList.map((x:string) => html`\n          <div class=\"SNS verticalGuide ${verticalSet[x]}\" style=\"left:${x}px\"/>\n        `)}`\n      }\n\n    /**** actual rendering ****/\n\n      const BoardStyle = (Board == null ? undefined : CSSStyleOfVisual(Board))\n\n      return html`<div class=\"SNS BoardView ${Classes}\" style=${BoardStyle}\n        onPointerDown=${LassoRecognizer} onPointerMove=${LassoRecognizer}\n        onPointerUp=${LassoRecognizer} onPointerCancel=${LassoRecognizer}\n      >\n        ${Board == null\n          ? html`<div class=\"SNS Placeholder\"><div>(no Board to show)</div></div>`\n          : StickerList == null\n            ? html`<div class=\"SNS Placeholder\"><div>(no Stickers to show)</div></div>`\n            : StickerList.map((Sticker:SNS_Sticker) => {\n                if (! Sticker.isVisible) { return '' }\n\n                const Geometry   = Sticker.Geometry\n// @ts-ignore TS2339 strange: TS does not recognize \"isSelectable\"\n                const selectable = Sticker.isSelectable     // Mode-independent!\n                const selected   = StickerIsSelected(Sticker)\n\n                return html`<${SNS_StickerView} Sticker=${Sticker} key=${Sticker.Id}\n                  selected=${selected && (Mode === 'run')}\n                  SelectionFrameStyle=${SelectionFrameStyle}\n                  Geometry=${Geometry}\n                  selectable=${selectable}\n                  builtinDragging=${selectable && builtinDraggingFor(Sticker)}\n                  builtinSelection=${selectable &&builtinSelectionFor(Sticker)}\n                />`\n              })\n        }\n\n        ${(StickerList != null) && (Mode === 'edit')\n          ? StickerList.map((Sticker:SNS_Sticker) => {\n              if (! Sticker.isVisible) { return '' }\n\n              const selected = StickerIsSelected(Sticker)\n\n              return html`\n                <${SNS_Cover} Sticker=${Sticker} key=${Sticker.Id+'c'}\n                  selected=${selected}\n                  onPointerEvent=${(Event:PointerEvent) => handleStickerEvent(Event,Sticker)}\n                />\n              `\n            })\n          : ''\n        }\n\n        ${(selectedStickers.length > 0)\n          ? selectedStickers.filter(\n              (Sticker:SNS_Sticker) => Sticker.isVisible\n            ).map((Sticker:SNS_Sticker) => {\n              const Id       = Sticker.Id\n              const Geometry = Sticker.Geometry\n              return html`\n                <${SNS_ShapeHandle} key=${Id+'nw'} Mode=\"nw\" Geometry=${Geometry}\n                  onPointerEvent=${(Event:PointerEvent) => handleShapeEvent(Event,'nw')}/>\n                <${SNS_ShapeHandle} key=${Id+'n'}  Mode=\"n\"  Geometry=${Geometry}\n                  onPointerEvent=${(Event:PointerEvent) => handleShapeEvent(Event,'n')}/>\n                <${SNS_ShapeHandle} key=${Id+'ne'} Mode=\"ne\" Geometry=${Geometry}\n                  onPointerEvent=${(Event:PointerEvent) => handleShapeEvent(Event,'ne')}/>\n                <${SNS_ShapeHandle} key=${Id+'e'}  Mode=\"e\"  Geometry=${Geometry}\n                  onPointerEvent=${(Event:PointerEvent) => handleShapeEvent(Event,'e')}/>\n                <${SNS_ShapeHandle} key=${Id+'se'} Mode=\"se\" Geometry=${Geometry}\n                  onPointerEvent=${(Event:PointerEvent) => handleShapeEvent(Event,'se')}/>\n                <${SNS_ShapeHandle} key=${Id+'s'}  Mode=\"s\"  Geometry=${Geometry}\n                  onPointerEvent=${(Event:PointerEvent) => handleShapeEvent(Event,'s')}/>\n                <${SNS_ShapeHandle} key=${Id+'sw'} Mode=\"sw\" Geometry=${Geometry}\n                  onPointerEvent=${(Event:PointerEvent) => handleShapeEvent(Event,'sw')}/>\n                <${SNS_ShapeHandle} key=${Id+'w'}  Mode=\"w\"  Geometry=${Geometry}\n                  onPointerEvent=${(Event:PointerEvent) => handleShapeEvent(Event,'w')}/>\n              `\n            })\n          : ''\n        }\n        ${this._LassoStart == null\n          ? ''\n          : html`<div class=\"SNS Lasso\" style=${CSSGeometryOfLasso()}></>`\n        }\n        ${horizontalGuides()}\n        ${verticalGuides()}\n      </div>`\n    }\n  }\n\n//------------------------------------------------------------------------------\n//--                             SNS_StickerView                              --\n//------------------------------------------------------------------------------\n\n  class SNS_StickerView extends Component {\n    private _Sticker:SNS_Sticker|undefined\n\n  /**** componentDidMount ****/\n\n    public componentDidMount ():void {\n      const Sticker = this._Sticker as SNS_Sticker\n\n      Sticker['_View'] = (this as Component).base\n      if (Sticker['_onMount'] != null) {\n        Sticker['_onMount']()\n      }\n    }\n\n  /**** componentWillUnmount ****/\n\n    public componentWillUnmount ():void {\n      const Sticker = this._Sticker as SNS_Sticker\n\n      Sticker['_View'] = undefined\n      if (Sticker['_onUnmount'] != null) {\n        Sticker['_onUnmount']()\n      }\n    }\n\n  /**** render ****/\n\n    public render (PropSet:Indexable):any {\n      let {\n        Sticker, selectable, selected, SelectionFrameStyle,\n        Geometry, builtinSelection, builtinDragging\n      } = PropSet\n\n      this._Sticker = Sticker\n\n      let { x,y, Width,Height } = Geometry\n        allowInteger('sticker x position',x)\n        allowInteger('sticker y position',y)\n        allowOrdinal     ('sticker width',Width)\n        allowOrdinal    ('sticker height',Height)\n      const CSSGeometry = (\n        (x != null) && (Width != null) && (y != null) && (Height != null)\n        ? `left:${x}px; top:${y}px; width:${Width}px; height:${Height}px; right:auto; bottom:auto;`\n        : ''\n      )\n\n      return html`<div class=\"\n        SNS Sticker ${selectable ? 'selectable' : ''} ${selected ? 'selected' : ''}\n      \" style=\"\n        ${CSSGeometry};\n        ${selected && (SelectionFrameStyle != null) ? `outline:${SelectionFrameStyle};` : ''}\n        ${CSSStyleOfVisual(Sticker) || ''}\n      \">\n        ${selectable\n          ? Sticker.Rendering({ builtinSelection,builtinDragging })\n          : Sticker.Rendering()\n        }\n      </div>`\n    }\n  }//------------------------------------------------------------------------------\n//--                                SNS_Cover                                 --\n//------------------------------------------------------------------------------\n\n  class SNS_Cover extends Component {\n    public render (PropSet:Indexable):any {\n      let { Sticker, onPointerEvent, ...otherProps } = PropSet\n\n      let { x,y, Width,Height } = Sticker.Geometry\n\n      const CSSGeometry = (\n        (x != null) && (Width != null) && (y != null) && (Height != null)\n        ? `left:${x}px; top:${y}px; width:${Width}px; height:${Height}px; right:auto; bottom:auto;`\n        : ''\n      )\n\n      return html`<div class=\"SNS Cover\" style=\"\n        ${CSSGeometry} ${Sticker.isLocked ? 'pointer-events:none' : ''}\n      \" ...${otherProps}\n        onPointerDown=${onPointerEvent} onPointerMove=${onPointerEvent}\n        onPointerUp=${onPointerEvent} onPointerCancel=${onPointerEvent}\n      />`\n    }\n  }\n\n//------------------------------------------------------------------------------\n//--                             SNS_ShapeHandle                              --\n//------------------------------------------------------------------------------\n\n  class SNS_ShapeHandle extends Component {\n    public render (PropSet:Indexable):any {\n      let { Mode, Geometry, onPointerEvent, ...otherProps } = PropSet\n\n      let { x,y, Width,Height } = Geometry\n      const xl = x-8, xm = Math.round(x+Width/2)-4,  xr = x+Width\n      const yt = y-8, ym = Math.round(y+Height/2)-4, yb = y+Height\n\n      let CSSGeometry, Cursor\n      switch (Mode) {\n        case 'nw': CSSGeometry = `left:${xl}px; top:${yt}px;`; Cursor = 'nwse'; break\n        case 'n':  CSSGeometry = `left:${xm}px; top:${yt}px;`; Cursor = 'ns';   break\n        case 'ne': CSSGeometry = `left:${xr}px; top:${yt}px;`; Cursor = 'nesw'; break\n        case 'e':  CSSGeometry = `left:${xr}px; top:${ym}px;`; Cursor = 'ew';   break\n        case 'se': CSSGeometry = `left:${xr}px; top:${yb}px;`; Cursor = 'nwse'; break\n        case 's':  CSSGeometry = `left:${xm}px; top:${yb}px;`; Cursor = 'ns';   break\n        case 'sw': CSSGeometry = `left:${xl}px; top:${yb}px;`; Cursor = 'nesw'; break\n        case 'w':  CSSGeometry = `left:${xl}px; top:${ym}px;`; Cursor = 'ew';   break\n      }\n      Cursor = 'cursor:' + Cursor + '-resize'\n\n      return html`<div class=\"SNS ShapeHandle\" style=\"${CSSGeometry} ${Cursor}\" ...${otherProps}\n        onPointerDown=${onPointerEvent} onPointerMove=${onPointerEvent}\n        onPointerUp=${onPointerEvent} onPointerCancel=${onPointerEvent}\n      />`\n    }\n  }\n\n// @ts-ignore TS2339 allow global variable \"SNS_BoardView\"\n  window.SNS_BoardView = SNS_BoardView\n\n  document.dispatchEvent(\n// @ts-ignore TS2339 allow global variable \"SNS_BoardView\"\n    new CustomEvent('SNS_BoardView',{ detail:window.SNS_BoardView })\n  )\n"],"names":["_excluded","_excluded2","_t","_t2","_t3","_t4","_t5","_t6","_t7","_t8","_t9","_t10","_t11","_t12","_t13","_t14","_","t","fromDocumentTo","Conversion","Stylesheet","document","createElement","setAttribute","innerHTML","head","appendChild","SNS_BoardView","Component","constructor","args","_Board","_StickerList","this","_pointedSticker","_selectedStickers","_SelectionLimit","Infinity","_LassoStart","_LassoEnd","_SelectionBeforeLasso","_ShapeMode","_shapedStickers","_initialGeometries","_SnapToGrid","_GridWidth","_GridHeight","_StickerRecognizerSlot","_ShapeHandleRecognizerSlot","_LassoRecognizerSlot","state","Value","_mountBoard","Board","base","_unmountBoard","undefined","componentDidMount","componentWillUnmount","rerender","setState","render","PropSet","my","Classes","StickerList","Placeholder","Mode","SelectionLimit","selectedStickers","onSelectionChange","onStickerSelected","onStickerDeselected","SelectionFrameStyle","SelectionHandleStyle","LassoMode","onGeometryChange","SnapToGrid","GridWidth","GridHeight","finishDraggingAndShaping","abortDraggingAndShaping","changeGeometriesTo","allowTextline","allowBoard","allowListSatisfying","ValueIsSticker","allowOneOf","allowOrdinal","allowFunction","allowText","allowBoolean","allowCardinal","selectedStickerSet","Set","selectStickers","SelectionA","SelectionB","newSelection","slice","forEach","Sticker","indexOf","push","length","StickersToSelect","StickersToDeselect","deselectedSticker","selectedSticker","StickerIsSelected","GeometryOfLasso","x","x0","y","y0","x1","y1","Width","Height","dragLassoTo","LassoX0","LassoY0","LassoWidth","LassoHeight","LassoX1","LassoY1","filter","isVisible","isLocked","isSelectable","Geometry","StickersCaughtByLasso","has","add","LassoRecognizer","DragClickRecognizerFor","onlyFrom","neverFrom","Threshold","onDragStarted","dx","dy","left","top","onDragContinued","onDragFinished","onDragCancelled","onClicked","GeometryList","changeGeometriesBy","initialGeometries","dX","dY","dW","dH","map","Math","max","xl","xr","yt","yb","xl_","round","xr_","yt_","yb_","min","StickerRecognizer","Event","shiftKey","metaKey","onStickerClick","SelectionChanged","shift","ShapeHandleRecognizer","DragRecognizerFor","handleShapeEvent","DragRecognizer","WeakMap","initialGeometry","BoardStyle","CSSStyleOfVisual","html","selectable","selected","SNS_StickerView","Id","Recognizer","get","set","delete","builtinDraggingFor","button","builtinSelectionFor","SNS_Cover","handleStickerEvent","SNS_ShapeHandle","CSSGeometryOfLasso","EdgeSet","CenterSet","ym","horizontalSet","horizontalList","horizontalGuides","xm","verticalSet","verticalList","verticalGuides","_Sticker","builtinSelection","builtinDragging","allowInteger","CSSGeometry","Rendering","onPointerEvent","otherProps","_objectWithoutPropertiesLoose","Cursor","window","dispatchEvent","CustomEvent","detail"],"mappings":"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"}